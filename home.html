<!doctype html><html><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"><title>PlantApp ‚Äî Home</title>
<link rel="icon" href="favicon.svg" type="image/svg+xml">
<script src="api-adapter.js"></script>
<script src="common.js"></script>
<style>
    body{font-family:system-ui,Arial;margin:0;padding:0;max-width:100%}
    .header{position:sticky;top:0;z-index:1000;background:#2c5f2d;color:#fff;padding:8px 10px;display:flex;justify-content:space-between;align-items:center;gap:8px}
    .header h1{margin:0;font-size:18px}
    .header-info{font-size:12px;text-align:right;line-height:1.3}
    .nav{position:sticky;top:65px;z-index:999;background:#f0f0f0;padding:5px 8px;display:flex;gap:2px;border-bottom:1px solid #ddd;overflow-x:auto;white-space:nowrap;-webkit-overflow-scrolling:touch}
    .nav a{text-decoration:none;color:#333;padding:6px 8px;border-radius:6px;font-size:14px;flex-shrink:0}
    .nav a.active{background:#2c5f2d;color:#fff}
    .nav a:hover{background:#ddd}
    .container{padding:18px;max-width:760px}
    .card{border:1px solid #ddd;padding:16px;border-radius:12px;margin:12px 0}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .mono{font-family:ui-monospace,monospace}
    button{padding:8px 12px;border-radius:8px;border:1px solid #888;background:#fafafa;cursor:pointer}
    input{padding:6px 10px;border:1px solid #ccc;border-radius:8px;width:120px}
    .muted{color:#666}
    .danger{color:#b00}
    .ok{color:#0a0}
    .status-badge{display:inline-block;padding:4px 10px;border-radius:12px;font-size:13px;font-weight:600}
    .status-timer{background:#e3f2fd;color:#1976d2}
    .status-sensor{background:#fff3e0;color:#f57c00}
    .status-off{background:#fce4ec;color:#c2185b}
    .status-manual{background:#e0e0e0;color:#616161}
    .status-active{background:#e0f7fa;color:#00838f}
    .status-launch{background:#fff3e0;color:#f57c00;animation:blink 1s ease-in-out infinite}
    @keyframes blink{0%,100%{opacity:1} 50%{opacity:0.4}}
    .mode-selector{display:flex;gap:4px;margin:12px 0;justify-content:center}
    .mode-btn{flex:1;max-width:110px;padding:10px 6px;border:2px solid #ddd;border-radius:12px;background:#fff;cursor:pointer;text-align:center;transition:all 0.2s}
    .mode-btn:hover{background:#f5f5f5}
    .mode-btn.selected{border-color:#2c5f2d;background:#e8f5e9}
    .mode-btn .mode-icon{font-size:28px;margin-bottom:6px}
    .mode-btn .mode-name{font-weight:600;font-size:14px}

    /* iOS-style toggle switch */
    .toggle-row{display:flex;justify-content:space-between;align-items:center;padding:12px 0}
    .toggle-switch{position:relative;display:inline-block;width:51px;height:31px;flex-shrink:0}
    .toggle-switch input{opacity:0;width:0;height:0}
    .toggle-slider{position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background:#ccc;border-radius:31px;transition:0.3s}
    .toggle-slider:before{position:absolute;content:"";height:27px;width:27px;left:2px;bottom:2px;background:#fff;border-radius:50%;transition:0.3s}
    input:checked+.toggle-slider{background:#34c759}
    input:checked+.toggle-slider:before{transform:translateX(20px)}

    /* Adaptive layout for narrow screens */
    @media (max-width: 400px) {
      .status-row{flex-direction:column;align-items:flex-start!important}
      .status-row>div{width:100%;margin-bottom:12px}
    }

    /* Vertical range slider styling */
    .speed-control{display:flex;flex-direction:column;align-items:center;padding:8px 12px;background:#f5f5f5;border-radius:8px;min-width:60px}
    .speed-label{font-size:11px;color:#666}
    .speed-value{font-family:ui-monospace,monospace;font-size:14px;font-weight:600;color:#2c5f2d}
    .speed-slider-wrap{position:relative;height:100px;width:32px;margin:8px 0;display:flex;align-items:center;justify-content:center}
    input[type="range"].vertical{writing-mode:vertical-lr;direction:rtl;width:8px;height:100px;background:transparent;outline:none;margin:0;padding:0}
    input[type="range"].vertical::-webkit-slider-runnable-track{width:8px;height:100px;background:linear-gradient(to top,#ddd 0%,#2c5f2d 100%);border-radius:4px}
    input[type="range"].vertical::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;width:20px;height:20px;background:#2c5f2d;border:3px solid #fff;border-radius:50%;cursor:pointer;box-shadow:0 2px 4px rgba(0,0,0,0.3);margin-left:-6px}

  </style> </head><body><div class="header"><div><h1 id="device-id-header" style="margin:0;font-size:15px">üå± Polivalka</h1><div style="font-size:13px">üìç <span id="location-text">‚Äî</span> / <span id="room-text">‚Äî</span><span id="custom-name-suffix"></span></div><div style="font-size:11px;margin-top:4px"><span id="battery-status">üîã ‚Äî</span> ¬∑ <span id="header-state">üí§ Standby</span></div></div><div id="header-warning" style="display:none;flex:1;text-align:center;padding:0 8px"><div style="background:#ff9800;color:#fff;padding:4px 12px;border-radius:12px;font-size:12px;font-weight:600;display:inline-block">‚ö†Ô∏è <span id="warning-text">Warning</span></div></div><div class="header-info"><div id="header-time" class="mono" style="font-size:11px">--:--</div><div style="font-size:11px" id="header-mode"><span id="mode-badge" class="status-badge status-off">Off</span></div><div style="font-size:11px" id="header-conn">üì° <span id="conn-text">Offline</span></div></div></div></div><div class="nav"><a href="fleet.html">Fleet</a><a href="home.html" class="active">Home</a><a href="identify.html" style="background:#e8f5e9">üå± Identify</a><a href="timer.html">Timer</a><a href="sensor.html">Sensor</a><a href="settings.html">Settings</a><a href="calibration.html">Calibration</a><a href="online.html">Online</a><a href="trends.html">Trends</a><a href="update.html">Update</a><a href="admin.html" id="admin-nav-link" style="display:none">Admin</a></div><div class="container"><div class="card"><h3>üíß Moisture Sensor</h3><div class="mono" style="font-size:16px;margin:8px 0" id="sensor-vals">ADC: ‚Äî | Moisture: ‚Äî %</div><div class="row"><button onclick="navigateTo('calibration.html')">Calibrate Sensor</button></div></div><div class="card"><h3>üö∞ Manual Control</h3><div style="display:flex;gap:12px"><div style="flex:1"><div class="row"><label>Duration:</label><input id="manual-duration" type="number" min="1" max="300" value="5" style="width:80px"><select id="manual-unit" style="padding:6px"><option value="sec">seconds</option><option value="min">minutes</option></select></div><div class="row" style="margin-top:10px"><button id="btn-manual" onclick="manualWater()">Water Now</button><button id="btn-stop" onclick="stopPump()" style="background:#b00;color:#fff;border-color:#900" disabled>STOP</button></div><div id="pump-running" style="display:none;margin-top:12px;padding:10px;background:#e8f5e9;border-radius:8px;border:2px solid #2c5f2d"><div style="font-weight:600;color:#2c5f2d">üíß Pump Running</div><div class="mono" style="font-size:13px;margin-top:4px"><span id="pump-elapsed">0s</span> / <span id="pump-total">0s</span><span id="pump-remaining" style="margin-left:8px">(‚Äî)</span></div></div><div class="row" style="margin-top:12px"><button onclick="navigateTo('calibration.html#pump')" style="font-size:12px;padding:6px 10px">Calibrate Pump</button></div></div><div style="display:flex;flex-direction:column;align-items:center;padding:8px 12px;background:#f5f5f5;border-radius:8px;min-width:50px"><div class="muted" style="font-size:11px;margin-bottom:4px">Speed</div><div class="mono" style="font-size:14px;font-weight:600;color:#2c5f2d" id="speed-display">100%</div><input type="range" class="vertical" id="speed-slider" min="0" max="100" value="100" oninput="speedPreview(this.value)" onchange="setSpeed(this.value)" style="margin:8px 0"><div style="display:flex;flex-direction:column;font-size:10px;color:#666;text-align:center"><span>0</span></div></div></div></div><div class="card"><h3>Operating Mode</h3><p class="muted">Select how the system should water your plants</p><div class="mode-selector"><div class="mode-btn" data-mode="manual" onclick="selectMode('manual')"><div class="mode-icon">‚úã</div><div class="mode-name">Manual</div><div class="muted" style="font-size:11px">Manual watering only</div></div><div class="mode-btn" data-mode="timer" onclick="selectMode('timer')"><div class="mode-icon">‚è∞</div><div class="mode-name">Timer</div><div class="muted" style="font-size:11px">Schedule-based</div></div><div class="mode-btn" data-mode="sensor" onclick="selectMode('sensor')"><div class="mode-icon">üíß</div><div class="mode-name">Sensor</div><div class="muted" style="font-size:11px">Moisture-based</div></div></div><p class="muted" style="margin-top:12px;font-size:12px"> ‚ÑπÔ∏è Configure schedules on <b>Timer</b> page, sensor settings on <b>Sensor</b> page, and calibration on <b>Calibration</b> page.</p></div><div class="card" style="padding:12px"><h3 style="margin-top:0">System Status</h3><div style="display:flex;gap:16px;flex-wrap:wrap;margin-bottom:12px"><div style="flex:1;min-width:100px"><div class="muted" style="font-size:12px">State</div><div id="current-state" class="mono" style="font-size:14px">‚Äî</div></div><div style="flex:1;min-width:100px"><div class="muted" style="font-size:12px">Mode</div><div id="current-mode" style="font-size:14px">‚Äî</div></div><div style="flex:1;min-width:120px"><div class="muted" style="font-size:12px">Last Watering</div><div id="last-watering" class="mono" style="font-size:14px">‚Äî</div></div></div><div id="sensor-status-details" style="display:none;border-top:1px solid #ddd;padding-top:12px;margin-top:4px"><div style="display:flex;gap:16px;flex-wrap:wrap;margin-bottom:8px"><div style="flex:1;min-width:100px"><div class="muted" style="font-size:12px">Current Moisture</div><div id="status-current-moisture" class="mono" style="font-size:14px">‚Äî</div></div><div style="flex:1;min-width:100px"><div class="muted" style="font-size:12px">Target Range</div><div id="status-target-range" class="mono" style="font-size:14px">‚Äî</div></div><div style="flex:1;min-width:120px"><div class="muted" style="font-size:12px">Daily Water</div><div id="status-daily-water" class="mono" style="font-size:14px">‚Äî</div></div></div><div id="status-progress-row" style="display:none;margin-bottom:8px"><div class="muted" style="font-size:12px">Watering Progress</div><div id="status-watering-progress" class="mono" style="font-size:14px">‚Äî</div></div><div id="status-warning-row" style="display:none;padding:8px;background:#fff3cd;border-radius:8px;border:1px solid #ffc107"><div style="font-weight:600;color:#856404">‚ö†Ô∏è Warning</div><div id="status-warning-message" style="font-size:13px;color:#856404;margin-top:4px">‚Äî</div></div></div><div id="timer-status-details" style="display:none;border-top:1px solid #ddd;padding-top:12px;margin-top:4px"><div style="display:flex;gap:16px;flex-wrap:wrap;margin-bottom:8px"><div style="flex:1;min-width:100px"><div class="muted" style="font-size:12px">Next Watering</div><div id="status-next-watering" class="mono" style="font-size:14px">‚Äî</div></div><div style="flex:1;min-width:100px"><div class="muted" style="font-size:12px">Schedules</div><div id="status-schedule-count" class="mono" style="font-size:14px">‚Äî</div></div><div style="flex:1;min-width:120px"><div class="muted" style="font-size:12px">Daily Water</div><div id="timer-daily-water" class="mono" style="font-size:14px">‚Äî</div></div></div><div id="timer-watering-row" style="display:none;margin-bottom:8px"><div class="muted" style="font-size:12px">Watering Duration</div><div id="timer-watering-duration" class="mono" style="font-size:14px">‚Äî</div></div><div id="timer-warning-row" style="display:none;padding:8px;background:#fff3cd;border-radius:8px;border:1px solid #ffc107"><div style="font-weight:600;color:#856404">‚ö†Ô∏è Warning</div><div id="timer-warning-message" style="font-size:13px;color:#856404;margin-top:4px">‚Äî</div></div></div></div><div class="card"><h3>Automation Control</h3><p class="muted" id="auto-instruction">Select Timer or Sensor mode to enable automation</p><div id="timer-auto-control" style="display:none;margin-top:12px"><div class="toggle-row"><div><div style="font-weight:600">Timer Auto Watering</div><div class="muted" style="font-size:12px">Schedule-based automatic watering</div></div><label class="toggle-switch"><input type="checkbox" id="timer-auto-toggle" onchange="toggleTimerAuto(this.checked)"><span class="toggle-slider"></span></label></div><div id="timer-arming-cancel-section" style="display:none;margin-top:12px;padding:12px;background:#fff3e0;border-radius:8px;border:2px solid #f57c00"><div style="display:flex;justify-content:space-between;align-items:center"><div><div style="font-weight:600;color:#e65100">‚è∞ Timer Countdown</div><div class="muted" style="font-size:13px;margin-top:4px">Timer mode starting in <span id="timer-arming-countdown-display" style="font-weight:600">15</span> seconds...</div></div><button onclick="cancelTimerArming()" style="background:#b00;color:#fff;border-color:#900;padding:8px 16px;font-weight:600">CANCEL</button></div></div><p class="muted" style="margin-top:8px;font-size:12px"> ‚ö†Ô∏è Before enabling: make sure pump and delivery tubes are properly connected! </p></div><div id="sensor-auto-control" style="display:none;margin-top:12px"><div class="toggle-row"><div><div style="font-weight:600">Sensor Auto Watering</div><div class="muted" style="font-size:12px">Moisture-based automatic watering</div></div><label class="toggle-switch"><input type="checkbox" id="sensor-auto-toggle" onchange="toggleSensorAuto(this.checked)"><span class="toggle-slider"></span></label></div><div id="arming-cancel-section" style="display:none;margin-top:12px;padding:12px;background:#fff3e0;border-radius:8px;border:2px solid #f57c00"><div style="display:flex;justify-content:space-between;align-items:center"><div><div style="font-weight:600;color:#e65100">üöÄ Launch Countdown</div><div class="muted" style="font-size:13px;margin-top:4px">Sensor mode starting in <span id="arming-countdown-display" style="font-weight:600">60</span> seconds...</div></div><button onclick="cancelArming()" style="background:#b00;color:#fff;border-color:#900;padding:8px 16px;font-weight:600">CANCEL</button></div></div><p class="muted" style="margin-top:8px;font-size:12px"> ‚ö†Ô∏è Before enabling: make sure sensor is inserted in soil and calibrated! </p></div></div></div> <script>
// Admin nav link, sleep(), mapStateToDisplay(), navigateTo() - moved to common.js

// –§–ª–∞–≥–∏ –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è —Ä–µ–∫—É—Ä—Å–∏–∏ –ø—Ä–∏ –ø—Ä–æ–≥—Ä–∞–º–º–Ω–æ–º –∏–∑–º–µ–Ω–µ–Ω–∏–∏ toggles
let updatingTimerToggle = false;
let updatingSensorToggle = false;

// –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏–π –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–æ–≤ (–¥–ª—è badge –∏–Ω–¥–∏–∫–∞—Ü–∏–∏)
let lastSensorState = 'DISABLED';
let lastTimerState = 'DISABLED';

// Cloud mode: –ª–æ–∫–∞–ª—å–Ω—ã–π countdown (ESP32 –Ω–µ —à–ª—ë—Ç countdown –∫–∞–∂–¥—É—é —Å–µ–∫—É–Ω–¥—É - —ç–∫–æ–Ω–æ–º–∏—è)
let sensorLaunchStartTime = null;  // timestamp –∫–æ–≥–¥–∞ —É–≤–∏–¥–µ–ª–∏ LAUNCH
let timerLaunchStartTime = null;
const SENSOR_LAUNCH_DURATION = 60;  // —Å–µ–∫—É–Ω–¥
const TIMER_LAUNCH_DURATION = 15;   // —Å–µ–∫—É–Ω–¥

// –õ–æ–∫–∞–ª—å–Ω—ã–π countdown ticker –¥–ª—è Cloud mode
if (IS_CLOUD) {
  setInterval(() => {
    // Sensor countdown
    if (lastSensorState === 'LAUNCH' && sensorLaunchStartTime) {
      const elapsed = Math.floor((Date.now() - sensorLaunchStartTime) / 1000);
      const remaining = Math.max(0, SENSOR_LAUNCH_DURATION - elapsed);
      document.getElementById('arming-countdown-display').textContent = remaining;
      const stateEl = document.getElementById('current-state');
      if (stateEl) {
        if (remaining > 0) {
          stateEl.innerHTML = `üöÄ LAUNCH IN ${remaining}s`;
        } else {
          stateEl.innerHTML = `üöÄ Starting...`;
        }
      }
    }
    // Timer countdown
    if (lastTimerState === 'LAUNCH' && timerLaunchStartTime) {
      const elapsed = Math.floor((Date.now() - timerLaunchStartTime) / 1000);
      const remaining = Math.max(0, TIMER_LAUNCH_DURATION - elapsed);
      document.getElementById('timer-arming-countdown-display').textContent = remaining;
      const stateEl = document.getElementById('current-state');
      if (stateEl) {
        if (remaining > 0) {
          stateEl.textContent = `‚è∞ LAUNCH ${remaining}s`;
        } else {
          stateEl.textContent = `‚è∞ Starting...`;
        }
      }
    }
  }, 1000);
}

async function updateStatus(){
  try {
    const s = await API.get('/status');

    // Cloud mode: update time and battery from /status (no separate endpoints)
    if (IS_CLOUD) {
      // Time: use timestamp from telemetry
      const timeEl = document.getElementById('header-time');
      if (s.timestamp) {
        const date = new Date(s.timestamp * 1000);
        const timeStr = date.toLocaleTimeString('en-US', {hour: '2-digit', minute: '2-digit', hour12: false});
        timeEl.textContent = timeStr;
        timeEl.className = 'mono ok';
      } else {
        timeEl.textContent = '--:--';
        timeEl.className = 'mono';
      }

      // Battery: from /status response (3 states only)
      // 1. üîã XX% - battery, not charging
      // 2. üîã XX% ‚ö° - battery, charging
      // 3. ‚ö° AC - no battery, AC power
      const batteryStatus = document.getElementById('battery-status');
      if (s.battery && s.battery.percent !== null && s.battery.percent !== undefined) {
        const percent = Math.round(s.battery.percent);
        const charging = s.battery.charging ? ' ‚ö°' : '';
        batteryStatus.textContent = `üîã ${percent}%${charging}`;
      } else {
        batteryStatus.textContent = '‚ö° AC';
      }
    }

    // Device ID header (first line) - show full device ID from DEVICE_ID or ESP32
    // Custom name goes in second line suffix if different from device_id
    if (IS_CLOUD && DEVICE_ID) {
      document.getElementById('device-id-header').textContent = 'üå± ' + DEVICE_ID;
    } else if (s.system_state?.device_name) {
      // AP mode - use device name from ESP32
      document.getElementById('device-id-header').textContent = 'üå± ' + s.system_state.device_name;
    }

    // Location and Room
    if (s.system_state?.location) {
      document.getElementById('location-text').textContent = s.system_state.location;
    }
    if (s.system_state?.room) {
      document.getElementById('room-text').textContent = s.system_state.room;
    }

    // Custom name suffix (always show device name, default to Plant)
    let customName = s.system_state?.device_name || 'Plant';
    if (customName === 'Polivalka') customName = 'Plant';
    document.getElementById('custom-name-suffix').textContent = ' / ' + customName;

    // Sensor data
    document.getElementById('sensor-vals').textContent =
      `ADC: ${s.adc}  |  Moisture: ${s.percent===null?'‚Äî':s.percent+' %'}`;

    // System State (–≤ System Status card, –Ω–µ –≤ header!)
    // Map internal state to user-friendly: Standby/Watering/Emergency
    const rawState = s.system_state?.state || 'OFF';
    const displayState = mapStateToDisplay(rawState, s.pump_running);
    const stateEl = document.getElementById('current-state');
    stateEl.innerHTML = `${displayState.emoji} ${displayState.text}`;
    stateEl.style.color = displayState.color;

    // Update header state (alongside battery)
    const headerStateEl = document.getElementById('header-state');
    if (headerStateEl) {
      headerStateEl.textContent = `${displayState.emoji} ${displayState.text}`;
    }

    // Mode badge —Å —É—á—ë—Ç–æ–º state –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–∞
    const mode = s.system_state?.mode || 'off';
    const modeBadge = document.getElementById('mode-badge');
    const modeText = mode.charAt(0).toUpperCase() + mode.slice(1);
    modeBadge.textContent = modeText;

    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∫–ª–∞—Å—Å badge –Ω–∞ –æ—Å–Ω–æ–≤–µ state –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–∞
    let badgeClass = 'status-badge';
    if (mode === 'sensor') {
      if (lastSensorState === 'LAUNCH') {
        badgeClass += ' status-launch'; // –ú–∏–≥–∞—é—â–∏–π –æ—Ä–∞–Ω–∂–µ–≤—ã–π
      } else if (lastSensorState !== 'DISABLED') {
        badgeClass += ' status-active'; // –ì–æ–ª—É–±–æ–π (STANDBY, PULSE, SETTLE, CHECK, COOLDOWN)
      } else {
        badgeClass += ' status-sensor'; // –û–±—ã—á–Ω—ã–π sensor (–æ—Ä–∞–Ω–∂–µ–≤—ã–π)
      }
    } else if (mode === 'timer') {
      if (lastTimerState === 'LAUNCH') {
        badgeClass += ' status-launch'; // –ú–∏–≥–∞—é—â–∏–π –æ—Ä–∞–Ω–∂–µ–≤—ã–π
      } else if (lastTimerState === 'ACTIVE' || lastTimerState === 'WATERING') {
        badgeClass += ' status-active'; // –ì–æ–ª—É–±–æ–π (ACTIVE, WATERING)
      } else {
        badgeClass += ' status-timer'; // –û–±—ã—á–Ω—ã–π timer (–≥–æ–ª—É–±–æ–π)
      }
    } else {
      badgeClass += ' status-off'; // –°–µ—Ä—ã–π (OFF)
    }
    modeBadge.className = badgeClass;

    document.getElementById('current-mode').textContent = modeText;

    // Connection status
    const connText = document.getElementById('conn-text');
    if (s.wifi_connected) {
      connText.textContent = 'Online';
      connText.style.color = '#0a0';
    } else {
      connText.textContent = 'Offline';
      connText.style.color = '#999';
    }

    // Mode selector - highlight current mode
    document.querySelectorAll('.mode-btn').forEach(btn => {
      btn.classList.toggle('selected', btn.dataset.mode === mode);
    });

    // Last watering
    if (s.system_state?.last_watering) {
      document.getElementById('last-watering').textContent = s.system_state.last_watering;
    }

    // Pump Running Indicator
    const pumpIndicator = document.getElementById('pump-running');
    const stopBtn = document.getElementById('btn-stop');
    const manualBtn = document.getElementById('btn-manual');

    // Cloud mode: Don't override pump UI if local countdown is active (optimistic update)
    // The local countdown provides instant feedback while we wait for telemetry update
    const localCountdownActive = IS_CLOUD && window.pumpCountdownInterval;

    if (s.pump_running) {
      pumpIndicator.style.display = 'block';
      stopBtn.disabled = false;

      // Disable manual button while pump is running
      manualBtn.disabled = true;
      manualBtn.style.background = '#ccc';
      manualBtn.style.borderColor = '#aaa';

      // Only update from server data if no local countdown (prevents flicker)
      if (!localCountdownActive) {
        const elapsedSec = Math.floor(s.pump_elapsed_ms / 1000);
        const totalSec = s.pump_remaining_ms > 0 ? Math.floor((s.pump_elapsed_ms + s.pump_remaining_ms) / 1000) : elapsedSec;
        const remainingSec = s.pump_remaining_ms > 0 ? Math.floor(s.pump_remaining_ms / 1000) : 0;

        // Show elapsed timer as button text
        manualBtn.textContent = `Watering ${elapsedSec}s`;

        document.getElementById('pump-elapsed').textContent = elapsedSec + 's';
        document.getElementById('pump-total').textContent = totalSec + 's';
        document.getElementById('pump-remaining').textContent = s.pump_remaining_ms > 0 ? `(${remainingSec}s left)` : '(manual mode)';
      }
    } else {
      // Pump NOT running according to server - always trust server state
      // Clear local countdown if still running (pump stopped on ESP32 side)
      if (localCountdownActive) {
        clearInterval(window.pumpCountdownInterval);
        window.pumpCountdownInterval = null;
      }

      // Reset UI
      pumpIndicator.style.display = 'none';
      stopBtn.disabled = true;

      // Re-enable manual button when pump stops
      manualBtn.disabled = false;
      manualBtn.textContent = 'Water Now';
      manualBtn.style.background = '';
      manualBtn.style.borderColor = '';
    }

    // Automation Control - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –Ω—É–∂–Ω—É—é —Å–µ–∫—Ü–∏—é
    const timerControl = document.getElementById('timer-auto-control');
    const sensorControl = document.getElementById('sensor-auto-control');
    const instruction = document.getElementById('auto-instruction');

    if (mode === 'timer') {
      timerControl.style.display = 'block';
      sensorControl.style.display = 'none';
      instruction.style.display = 'none';

      // NOTE: Toggle state will be updated by updateTimerControllerStatus()
      // based on actual timer_controller state (not just mode)
    } else if (mode === 'sensor') {
      timerControl.style.display = 'none';
      sensorControl.style.display = 'block';
      instruction.style.display = 'none';

      // NOTE: Toggle state will be updated by updateSensorControllerStatus()
      // based on actual sensor_controller state (not just mode)
    } else {
      timerControl.style.display = 'none';
      sensorControl.style.display = 'none';
      instruction.style.display = 'block';
    }
  } catch(e) {
    // Suppress noisy network errors (ERR_INTERNET_DISCONNECTED, Failed to fetch)
    if (!e.message?.includes('fetch')) {
      console.error('Status update failed:', e);
    }
  }
}

async function updateTime(){
  try {
    const t = await API.get('/time/status');
    const timeEl = document.getElementById('header-time');
    if (t.time_set && t.current_time) {
      timeEl.textContent=t.current_time.substring(11,16);
      timeEl.className = 'mono ok';
    } else {
      timeEl.textContent = '--:--';
      timeEl.className = 'mono danger';
    }
  } catch(e) {
    console.error('Time update failed:', e);
  }
}

async function updateBattery(){
  try {
    const b = await API.get('/battery/status');
    const batteryStatus = document.getElementById('battery-status');

    // 3 states only:
    // 1. üîã XX% - battery, not charging
    // 2. üîã XX% ‚ö° - battery, charging
    // 3. ‚ö° AC - no battery, AC power
    if (b.percent !== null && b.percent !== undefined) {
      const percent = Math.round(b.percent);
      const charging = b.charging ? ' ‚ö°' : '';
      batteryStatus.textContent = `üîã ${percent}%${charging}`;
    } else {
      batteryStatus.textContent = '‚ö° AC';
    }
  } catch(e) {
    document.getElementById('battery-status').textContent = '‚ö° AC';
  }
}

async function selectMode(mode) {
  try {
    // Check if switching away from active controller
    const currentMode = document.querySelector('.mode-btn.selected')?.getAttribute('data-mode');

    if (currentMode === 'timer' && lastTimerState !== 'DISABLED' && mode !== 'timer') {
      if (!confirm('‚ö†Ô∏è Timer automation is active!\n\nSwitching mode will disable it.\nYou will need to re-enable automation after switching back.\n\nContinue?')) {
        return; // User cancelled
      }
    }

    if (currentMode === 'sensor' && lastSensorState !== 'DISABLED' && mode !== 'sensor') {
      if (!confirm('‚ö†Ô∏è Sensor automation is active!\n\nSwitching mode will disable it.\nYou will need to re-enable automation after switching back.\n\nContinue?')) {
        return; // User cancelled
      }
    }

    // Optimistic UI update - immediately show selected mode
    document.querySelectorAll('.mode-btn').forEach(btn => {
      btn.classList.toggle('selected', btn.dataset.mode === mode);
    });
    document.getElementById('current-mode').textContent = mode.charAt(0).toUpperCase() + mode.slice(1);
    const modeBadge = document.getElementById('mode-badge');
    modeBadge.textContent = mode.charAt(0).toUpperCase() + mode.slice(1);
    modeBadge.className = 'status-badge status-' + mode;

    await API.post('/mode', {mode: mode});

    // Cloud mode: wait for MQTT to propagate, then refresh
    if (IS_CLOUD) {
      await sleep(2000);
    }
    updateStatus();
    updateControllerStatus();
  } catch(e) {
    alert('Error setting mode: ' + e.message);
    // Revert optimistic update on error
    updateStatus();
  }
}

async function manualWater(){
  const duration = parseInt(document.getElementById('manual-duration').value);
  const unit = document.getElementById('manual-unit').value;
  const sec = unit === 'min' ? duration * 60 : duration;

  const btn = document.getElementById('btn-manual');
  const stopBtn = document.getElementById('btn-stop');
  const pumpIndicator = document.getElementById('pump-running');

  btn.disabled = true;
  btn.textContent = 'Starting...';
  btn.style.background = '#ccc';

  try {
    await API.post('/pump?sec=' + sec);

    // Cloud mode: Optimistic UI update (MQTT command sent, show pump running immediately)
    // ESP32 will execute the command, but telemetry update takes 2-3 min
    if (IS_CLOUD) {
      // Show pump running indicator immediately
      pumpIndicator.style.display = 'block';
      stopBtn.disabled = false;
      btn.textContent = `Watering ${sec}s`;

      // Set up local countdown display
      document.getElementById('pump-elapsed').textContent = '0s';
      document.getElementById('pump-total').textContent = sec + 's';
      document.getElementById('pump-remaining').textContent = `(${sec}s left)`;

      // Start local countdown timer for Cloud mode
      let elapsed = 0;
      const countdownInterval = setInterval(() => {
        elapsed++;
        const remaining = Math.max(0, sec - elapsed);
        document.getElementById('pump-elapsed').textContent = elapsed + 's';
        document.getElementById('pump-remaining').textContent = `(${remaining}s left)`;
        btn.textContent = `Watering ${elapsed}s`;

        if (elapsed >= sec) {
          clearInterval(countdownInterval);
          // Pump finished - reset UI
          pumpIndicator.style.display = 'none';
          stopBtn.disabled = true;
          btn.disabled = false;
          btn.textContent = 'Water Now';
          btn.style.background = '';
          btn.style.borderColor = '';
        }
      }, 1000);

      // Store interval ID so STOP can clear it
      window.pumpCountdownInterval = countdownInterval;
    } else {
      // Local mode: ESP32 responds immediately
      updateStatus();
    }
  } catch(e) {
    alert('Error: ' + e.message);
    btn.disabled = false;
    btn.textContent = 'Water Now';
    btn.style.background = '';
  }
}

async function toggleTimerAuto(checked){
  // Ignore programmatic changes
  if (updatingTimerToggle) return;

  try {
    if (checked) {
      // Enable timer controller (starts LAUNCH countdown)
      const resp = await API.post('/timer/controller/enable');
      if (!resp.success) {
        alert(resp.message || 'Failed to enable timer controller');
        document.getElementById('timer-auto-toggle').checked = false;
        return;
      }
      // In Cloud mode, wait for ESP32 to publish updated telemetry
      if (IS_CLOUD) await sleep(2000);
    } else {
      // Disable timer controller (but keep mode as timer)
      await API.post('/timer/controller/disable');
      // In Cloud mode, wait for ESP32 to publish updated telemetry
      if (IS_CLOUD) await sleep(2000);
    }
    updateStatus();
    updateControllerStatus(); // Update UI
  } catch(e) {
    alert('Error: ' + e.message);
    document.getElementById('timer-auto-toggle').checked = !checked; // revert on error
  }
}

async function toggleSensorAuto(checked){
  // Ignore programmatic changes
  if (updatingSensorToggle) return;

  try {
    if (checked) {
      // Enable sensor controller (starts LAUNCH countdown)
      const resp = await API.post('/sensor/controller/enable');
      if (!resp.success) {
        alert(resp.message || 'Failed to enable sensor controller');
        document.getElementById('sensor-auto-toggle').checked = false;
        return;
      }
      // In Cloud mode, wait for ESP32 to publish updated telemetry
      if (IS_CLOUD) await sleep(2000);
    } else {
      // Disable sensor controller (but keep mode as sensor)
      await API.post('/sensor/controller/disable');
      // In Cloud mode, wait for ESP32 to publish updated telemetry
      if (IS_CLOUD) await sleep(2000);
    }
    updateStatus();
    updateControllerStatus(); // Update UI
  } catch(e) {
    alert('Error: ' + e.message);
    document.getElementById('sensor-auto-toggle').checked = !checked; // revert on error
  }
}

async function stopPump(){
  const btn = document.getElementById('btn-manual');
  const stopBtn = document.getElementById('btn-stop');
  const pumpIndicator = document.getElementById('pump-running');

  stopBtn.disabled = true;
  stopBtn.textContent = 'Stopping...';

  try {
    await API.post('/pump/stop');

    // Cloud mode: Optimistic UI update
    if (IS_CLOUD) {
      // Clear the countdown timer if running
      if (window.pumpCountdownInterval) {
        clearInterval(window.pumpCountdownInterval);
        window.pumpCountdownInterval = null;
      }

      // Reset UI immediately
      pumpIndicator.style.display = 'none';
      btn.disabled = false;
      btn.textContent = 'Water Now';
      btn.style.background = '';
      btn.style.borderColor = '';
    } else {
      // Local mode: ESP32 responds immediately
      updateStatus();
    }

    // Reset STOP button
    stopBtn.textContent = 'STOP';
  } catch(e) {
    alert('Error: ' + e.message);
    stopBtn.disabled = false;
    stopBtn.textContent = 'STOP';
  }
}

async function cancelArming(){
  try {
    const resp = await API.post('/sensor/controller/cancel');
    if (resp.success) {
      // Also disable the toggle
      document.getElementById('sensor-auto-toggle').checked = false;
      updateStatus();
      updateControllerStatus(); // Use unified update instead
    } else {
      alert(resp.message || 'Failed to cancel launch');
    }
  } catch(e) {
    alert('Error: ' + e.message);
  }
}

// monitorWiFiMode() - moved to common.js

// –ö–†–ò–¢–ò–ß–ù–û: –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞, –Ω–µ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ!
// –ò–Ω—Ç–µ—Ä–≤–∞–ª—ã —Ä–∞–∑–Ω–µ—Å–µ–Ω—ã —á—Ç–æ–±—ã –Ω–µ –Ω–∞–≥—Ä—É–∂–∞—Ç—å ESP32 –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–º–∏ –∑–∞–ø—Ä–æ—Å–∞–º–∏
setInterval(updateStatus, 5000);   // –∫–∞–∂–¥—ã–µ 5 —Å–µ–∫

// Time/Battery/WiFi monitoring —Ç–æ–ª—å–∫–æ –≤ –ª–æ–∫–∞–ª—å–Ω–æ–º —Ä–µ–∂–∏–º–µ (Cloud –ø–æ–ª—É—á–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ —á–µ—Ä–µ–∑ /status)
if (!IS_CLOUD) {
  setInterval(updateTime, 60000);    // –∫–∞–∂–¥—ã–µ 60 —Å–µ–∫
  setInterval(updateBattery, 10000); // –∫–∞–∂–¥—ã–µ 10 —Å–µ–∫ (–±—ã–ª–æ 5, –∫–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤–∞–ª–æ —Å updateStatus)
  setInterval(monitorWiFiMode, 5000); // –∫–∞–∂–¥—ã–µ 5 —Å–µ–∫ - –±–∞–ª–∞–Ω—Å UX/–Ω–∞–≥—Ä—É–∑–∫–∞ (–∞–∫—Ç–∏–≤–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏)
}

// Cloud mode: –ø–æ–∫–∞–∑–∞—Ç—å device ID –≤ header —Å—Ä–∞–∑—É (–¥–æ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö –∏–∑ API)
if (IS_CLOUD && DEVICE_ID) {
  document.getElementById('device-id-header').textContent = 'üå± ' + DEVICE_ID;
  document.title = `${DEVICE_ID} ‚Äî Home`;
} else if (IS_CLOUD && !DEVICE_ID) {
  // ERROR: Cloud mode requires device_id parameter
  document.body.innerHTML = `
    <div style="display:flex;flex-direction:column;align-items:center;justify-content:center;height:100vh;text-align:center;padding:20px">
      <h1 style="color:#b00">‚ö†Ô∏è Missing Device ID</h1>
      <p style="font-size:16px;color:#666;max-width:500px">
        This page requires a device ID parameter to work in cloud mode.<br>
        Please select a device from the fleet page.
      </p>
      <a href="fleet.html" style="display:inline-block;margin-top:20px;padding:12px 24px;background:#2c5f2d;color:#fff;text-decoration:none;border-radius:8px;font-weight:600">
        ‚Üê Go to Fleet
      </a>
      <p style="margin-top:40px;font-size:13px;color:#999">
        Expected URL format: home.html?device=Polivalka-BB00C1
      </p>
    </div>
  `;
  throw new Error('Missing device_id parameter in cloud mode');
}

// –ü–µ—Ä–≤–∞—è –∑–∞–≥—Ä—É–∑–∫–∞: –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ —Å –∑–∞–¥–µ—Ä–∂–∫–∞–º–∏
updateStatus();

// Time/Battery/WiFi —Ç–æ–ª—å–∫–æ –¥–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —Ä–µ–∂–∏–º–∞
if (!IS_CLOUD) {
  setTimeout(() => updateTime(), 500);     // —á–µ—Ä–µ–∑ 0.5 —Å–µ–∫
  setTimeout(() => updateBattery(), 1000); // —á–µ—Ä–µ–∑ 1 —Å–µ–∫
  setTimeout(() => monitorWiFiMode(), 1500); // —á–µ—Ä–µ–∑ 1.5 —Å–µ–∫
}

// Sensor Controller Status (for Sensor mode)
var sensorPresetCache = null;

async function updateSensorControllerStatus() {
  try {
    const mode = document.querySelector('.mode-btn.selected')?.getAttribute('data-mode');

    // Hide sensor details if not in sensor mode
    const detailsSection = document.getElementById('sensor-status-details');
    if (mode !== 'sensor') {
      detailsSection.style.display = 'none';
      document.getElementById('header-warning').style.display = 'none';
      return;
    }

    // Fetch sensor controller status
    const sc = await API.get('/sensor/controller/status');

    // Save state globally for badge indication
    // Cloud mode: track LAUNCH start time for local countdown
    if (IS_CLOUD && sc.state === 'LAUNCH' && lastSensorState !== 'LAUNCH') {
      sensorLaunchStartTime = Date.now();  // Just entered LAUNCH
    } else if (sc.state !== 'LAUNCH') {
      sensorLaunchStartTime = null;  // Exited LAUNCH
    }
    lastSensorState = sc.state;

    // Fetch preset config (cache for 10 seconds to reduce load)
    if (!sensorPresetCache || Date.now() - sensorPresetCache.timestamp > 10000) {
      const preset = await API.get('/sensor/preset');
      sensorPresetCache = {data: preset, timestamp: Date.now()};
    }
    const preset = sensorPresetCache.data;

    // Show sensor details section
    detailsSection.style.display = 'block';

    // Only update State field if we're actually in sensor mode!
    if (mode === 'sensor') {
      const stateEl = document.getElementById('current-state');
      let stateText = sc.state;
      let stateColor = '#333';

      if (sc.state === 'LAUNCH') {
        stateText = `üöÄ LAUNCH IN ${sc.arming_countdown}s`;
        stateColor = '#f57c00';
      } else if (sc.state === 'STANDBY') {
        stateText = 'üëÄ Monitoring';
        stateColor = '#2c5f2d';
      } else if (sc.state === 'PULSE') {
        stateText = 'üíß Watering';
        stateColor = '#1976d2';
      } else if (sc.state === 'SETTLE') {
        stateText = '‚è≥ Absorbing';
        stateColor = '#9c27b0';
      } else if (sc.state === 'CHECK') {
        stateText = 'üîç Checking';
        stateColor = '#ff9800';
      } else if (sc.state === 'COOLDOWN') {
        const cooldownMin = Math.floor(sc.cooldown_remaining / 60);
        stateText = `üò¥ Resting (${cooldownMin}m)`;
        stateColor = '#607d8b';
      } else if (sc.state === 'DISABLED') {
        stateText = '‚è∏Ô∏è Disabled';
        stateColor = '#999';
      }

      stateEl.innerHTML = stateText;
      stateEl.style.color = stateColor;
    }

    // Current Moisture (duplicate from sensor reading)
    document.getElementById('status-current-moisture').textContent = sc.moisture_pct + '%';

    // Target Range
    if (preset && preset.start_pct && preset.stop_pct) {
      document.getElementById('status-target-range').textContent =
        `${preset.start_pct}-${preset.stop_pct}%`;
    }

    // Daily Water
    if (preset && preset.max_water_day_ml) {
      const dailyText = `${sc.daily_water_ml} / ${preset.max_water_day_ml} ml`;
      const dailyEl = document.getElementById('status-daily-water');
      dailyEl.textContent = dailyText;

      // Color code if approaching or exceeding limit
      if (sc.daily_hard_limit_reached) {
        dailyEl.style.color = '#b00';
        dailyEl.style.fontWeight = '600';
      } else if (sc.daily_water_ml > preset.max_water_day_ml * 0.8) {
        dailyEl.style.color = '#f57c00';
      } else {
        dailyEl.style.color = '#333';
        dailyEl.style.fontWeight = 'normal';
      }
    }

    // Watering Progress (show only during active watering cycle)
    const progressRow = document.getElementById('status-progress-row');
    if (sc.state === 'PULSE' || sc.state === 'SETTLE' || sc.state === 'CHECK') {
      progressRow.style.display = 'block';
      const progressText = `Pulse ${sc.pulses_delivered} / ${preset.max_pulses || '?'}, ${sc.total_water_ml} ml delivered`;
      document.getElementById('status-watering-progress').textContent = progressText;
    } else {
      progressRow.style.display = 'none';
    }

    // Warning display
    const warningRow = document.getElementById('status-warning-row');
    const headerWarning = document.getElementById('header-warning');

    if (sc.warning_active && sc.warning_msg) {
      warningRow.style.display = 'block';
      document.getElementById('status-warning-message').textContent = sc.warning_msg;

      // Show warning in header
      headerWarning.style.display = 'flex';
      document.getElementById('warning-text').textContent = sc.warning_msg.substring(0, 40) + (sc.warning_msg.length > 40 ? '...' : '');
    } else {
      warningRow.style.display = 'none';
      headerWarning.style.display = 'none';
    }

    // Launch cancel section (show only during LAUNCH state)
    const armingSection = document.getElementById('arming-cancel-section');
    if (sc.state === 'LAUNCH') {
      armingSection.style.display = 'block';
      document.getElementById('arming-countdown-display').textContent = sc.arming_countdown;
    } else {
      armingSection.style.display = 'none';
    }

    // Update toggle state ONLY if we're actually in sensor mode
    // This prevents fighting between timer and sensor toggles
    const currentModeEl = document.querySelector('.mode-btn.selected');
    if (currentModeEl && currentModeEl.getAttribute('data-mode') === 'sensor') {
      const toggleEl = document.getElementById('sensor-auto-toggle');
      const shouldBeChecked = (sc.state !== 'DISABLED');
      if (toggleEl && toggleEl.checked !== shouldBeChecked) {
        updatingSensorToggle = true;
        toggleEl.checked = shouldBeChecked;
        updatingSensorToggle = false;
      }
    }

  } catch(e) {
    // Suppress noisy network errors
    if (!e.message?.includes('fetch')) {
      console.error('Sensor Controller status update failed:', e);
    }
  }
}

// Removed individual sensor controller interval - now handled by unified updateLoop

// Timer Controller Status (for Timer mode)
async function updateTimerControllerStatus() {
  try {
    const mode = document.querySelector('.mode-btn.selected')?.getAttribute('data-mode');

    // Hide timer details if not in timer mode
    const detailsSection = document.getElementById('timer-status-details');
    if (mode !== 'timer') {
      detailsSection.style.display = 'none';
      return;
    }

    // Fetch timer controller status
    const tc = await API.get('/timer/controller/status');

    // Save state globally for badge indication
    // Cloud mode: track LAUNCH start time for local countdown
    if (IS_CLOUD && tc.state === 'LAUNCH' && lastTimerState !== 'LAUNCH') {
      timerLaunchStartTime = Date.now();  // Just entered LAUNCH
    } else if (tc.state !== 'LAUNCH') {
      timerLaunchStartTime = null;  // Exited LAUNCH
    }
    lastTimerState = tc.state;

    // Fetch schedules count
    const schedules = await API.get('/schedules');

    // Show timer details section
    detailsSection.style.display = 'block';

    // Only update State field if we're actually in timer mode!
    if (mode === 'timer') {
      const stateEl = document.getElementById('current-state');
      let stateText = tc.state;
      let stateColor = '#333';

      if (tc.state === 'LAUNCH') {
        stateText = `‚è∞ LAUNCH ${tc.arming_countdown_sec}s`;
        stateColor = '#f57c00';
      } else if (tc.state === 'ACTIVE') {
        stateText = '‚è∞ Active';
        stateColor = '#2c5f2d';
      } else if (tc.state === 'WATERING') {
        stateText = 'üíß Watering';
        stateColor = '#1976d2';
      } else if (tc.state === 'DISABLED') {
        stateText = '‚úã Disabled';
        stateColor = '#666';
      }

      stateEl.textContent = stateText;
      stateEl.style.color = stateColor;
    }

    // Update timer details
    document.getElementById('status-next-watering').textContent = tc.next_watering_str || 'No schedules';
    document.getElementById('status-schedule-count').textContent = tc.schedule_exists ? `${schedules.count} active` : 'None';
    document.getElementById('timer-daily-water').textContent = tc.daily_water_ml + ' ml';

    // Watering duration (if currently watering)
    const wateringRow = document.getElementById('timer-watering-row');
    if (tc.state === 'WATERING' && tc.current_duration_sec > 0) {
      wateringRow.style.display = 'block';
      document.getElementById('timer-watering-duration').textContent = `${tc.current_duration_sec}s`;
    } else {
      wateringRow.style.display = 'none';
    }

    // Warning display
    const warningRow = document.getElementById('timer-warning-row');
    const headerWarning = document.getElementById('header-warning');

    if (tc.warning_active && tc.warning_msg) {
      warningRow.style.display = 'block';
      document.getElementById('timer-warning-message').textContent = tc.warning_msg;

      // Show warning in header (if sensor not already showing one)
      if (mode === 'timer') {
        headerWarning.style.display = 'flex';
        document.getElementById('warning-text').textContent = tc.warning_msg.substring(0, 40) + (tc.warning_msg.length > 40 ? '...' : '');
      }
    } else {
      warningRow.style.display = 'none';
      if (mode === 'timer') {
        headerWarning.style.display = 'none';
      }
    }

    // Launch cancel section (show only during LAUNCH state)
    const armingSection = document.getElementById('timer-arming-cancel-section');
    if (tc.state === 'LAUNCH') {
      armingSection.style.display = 'block';
      document.getElementById('timer-arming-countdown-display').textContent = tc.arming_countdown_sec;
    } else {
      armingSection.style.display = 'none';
    }

    // Update toggle state ONLY if we're actually in timer mode
    // This prevents fighting between timer and sensor toggles
    const currentModeEl = document.querySelector('.mode-btn.selected');
    if (currentModeEl && currentModeEl.getAttribute('data-mode') === 'timer') {
      const toggleEl = document.getElementById('timer-auto-toggle');
      const shouldBeChecked = (tc.state !== 'DISABLED');
      if (toggleEl && toggleEl.checked !== shouldBeChecked) {
        updatingTimerToggle = true;
        toggleEl.checked = shouldBeChecked;
        updatingTimerToggle = false;
      }
    }

  } catch(e) {
    // Suppress noisy network errors
    if (!e.message?.includes('fetch')) {
      console.error('Timer Controller status update failed:', e);
    }
  }
}

// Cancel timer arming
async function cancelTimerArming() {
  try {
    await API.post('/timer/controller/cancel');
    updateControllerStatus(); // Use unified update instead
  } catch(e) {
    alert('Error canceling timer: ' + e.message);
  }
}

// Removed individual timer controller interval - now handled by unified updateLoop

// Unified controller status update loop - only update the active mode's controller
async function updateControllerStatus() {
  const mode = document.querySelector('.mode-btn.selected')?.getAttribute('data-mode');

  // Only update the controller for the current mode
  // This prevents toggle fighting and saves energy
  if (mode === 'sensor') {
    await updateSensorControllerStatus();
  } else if (mode === 'timer') {
    await updateTimerControllerStatus();
  }
  // If mode is 'off', neither controller needs updating
}

// Single update loop for controller status (saves energy, prevents conflicts)
setInterval(updateControllerStatus, 2000); // every 2 seconds
setTimeout(updateControllerStatus, 1000); // initial load after 1 sec

// Pump speed control
function speedPreview(val){document.getElementById('speed-display').textContent=val+'%';}
let speedDebounceTimer=null;
async function setSpeed(val){
  // Debounce to avoid multiple rapid calls on touch devices
  if(speedDebounceTimer) clearTimeout(speedDebounceTimer);
  speedDebounceTimer=setTimeout(async()=>{
    try{await API.post('/pump/speed?value='+val);}
    catch(e){alert('Speed set failed');}
  },300);
}
async function loadPumpSpeed(){
  try{
    const s=await API.get('/pump/status');
    const speed=s.speed!==undefined?s.speed:100;
    document.getElementById('speed-slider').value=speed;
    document.getElementById('speed-display').textContent=speed+'%';
  }catch(e){}
}
setTimeout(loadPumpSpeed, 1500);
</script> </body></html>