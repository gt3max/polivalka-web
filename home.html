<!doctype html><html><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"><title>PlantApp ‚Äî Home</title>
<link rel="icon" href="favicon.svg" type="image/svg+xml">
<script src="api-adapter.js"></script>
<script src="common.js"></script>
<style>
    body{font-family:system-ui,Arial;margin:0;padding:0;max-width:100%}
    .header{position:sticky;top:0;z-index:1000;background:#2c5f2d;color:#fff;padding:8px 10px;display:flex;justify-content:space-between;align-items:center;gap:8px}
    .header h1{margin:0;font-size:18px}
    .header-info{font-size:12px;text-align:right;line-height:1.3}
    .nav{position:sticky;top:65px;z-index:999;background:#f0f0f0;padding:5px 8px;display:flex;gap:2px;border-bottom:1px solid #ddd;overflow-x:auto;white-space:nowrap;-webkit-overflow-scrolling:touch}
    .nav a{text-decoration:none;color:#333;padding:6px 8px;border-radius:6px;font-size:14px;flex-shrink:0}
    .nav a.active{background:#2c5f2d;color:#fff}
    .nav a:hover{background:#ddd}
    .container{padding:18px;max-width:760px}
    .card{border:1px solid #ddd;padding:16px;border-radius:12px;margin:12px 0}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .mono{font-family:ui-monospace,monospace}
    button{padding:8px 12px;border-radius:8px;border:1px solid #888;background:#fafafa;cursor:pointer}
    input{padding:6px 10px;border:1px solid #ccc;border-radius:8px;width:120px}
    .muted{color:#666}
    .danger{color:#b00}
    .ok{color:#0a0}
    .status-badge{display:inline-block;padding:4px 10px;border-radius:12px;font-size:13px;font-weight:600}
    .status-timer{background:#e3f2fd;color:#1976d2}
    .status-sensor{background:#fff3e0;color:#f57c00}
    .status-off{background:#fce4ec;color:#c2185b}
    .status-manual{background:#e0e0e0;color:#616161}
    .status-active{background:#e0f7fa;color:#00838f}
    .status-launch{background:#fff3e0;color:#f57c00;animation:blink 1s ease-in-out infinite}
    @keyframes blink{0%,100%{opacity:1} 50%{opacity:0.4}}
    .mode-selector{display:flex;gap:4px;margin:12px 0;justify-content:center}
    .mode-btn{flex:1;max-width:110px;padding:10px 6px;border:2px solid #ddd;border-radius:12px;background:#fff;cursor:pointer;text-align:center;transition:all 0.2s}
    .mode-btn:hover{background:#f5f5f5}
    .mode-btn.selected{border-color:#2c5f2d;background:#e8f5e9}
    .mode-btn .mode-icon{font-size:28px;margin-bottom:6px}
    .mode-btn .mode-name{font-weight:600;font-size:14px}

    /* iOS-style toggle switch */
    .toggle-row{display:flex;justify-content:space-between;align-items:center;padding:12px 0}
    .toggle-switch{position:relative;display:inline-block;width:51px;height:31px;flex-shrink:0}
    .toggle-switch input{opacity:0;width:0;height:0}
    .toggle-slider{position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background:#ccc;border-radius:31px;transition:0.3s}
    .toggle-slider:before{position:absolute;content:"";height:27px;width:27px;left:2px;bottom:2px;background:#fff;border-radius:50%;transition:0.3s}
    input:checked+.toggle-slider{background:#34c759}
    input:checked+.toggle-slider:before{transform:translateX(20px)}

    /* Adaptive layout for narrow screens */
    @media (max-width: 400px) {
      .status-row{flex-direction:column;align-items:flex-start!important}
      .status-row>div{width:100%;margin-bottom:12px}
    }

    /* Vertical range slider styling */
    .speed-control{display:flex;flex-direction:column;align-items:center;padding:8px 12px;background:#f5f5f5;border-radius:8px;min-width:60px}
    .speed-label{font-size:11px;color:#666}
    .speed-value{font-family:ui-monospace,monospace;font-size:14px;font-weight:600;color:#2c5f2d}
    .speed-slider-wrap{position:relative;height:100px;width:32px;margin:8px 0;display:flex;align-items:center;justify-content:center}
    input[type="range"].vertical{writing-mode:vertical-lr;direction:rtl;width:8px;height:100px;background:transparent;outline:none;margin:0;padding:0}
    input[type="range"].vertical::-webkit-slider-runnable-track{width:8px;height:100px;background:linear-gradient(to top,#ddd 0%,#2c5f2d 100%);border-radius:4px}
    input[type="range"].vertical::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;width:20px;height:20px;background:#2c5f2d;border:3px solid #fff;border-radius:50%;cursor:pointer;box-shadow:0 2px 4px rgba(0,0,0,0.3);margin-left:-6px}

    /* Plant card expand/collapse */
    .plant-row{display:flex;gap:12px;align-items:center;cursor:pointer;transition:background 0.2s}
    .plant-row:hover{background:rgba(0,0,0,0.02);border-radius:8px;margin:-4px;padding:4px}
    .plant-row .expand-icon{font-size:12px;color:#666;transition:transform 0.2s;flex-shrink:0}
    .plant-row.expanded .expand-icon{transform:rotate(90deg)}
    .plant-details{display:none;padding:12px 0 0 24px;border-top:1px solid #c8e6c9;margin-top:12px}
    .plant-details.expanded{display:block}
    .plant-details .detail-row{display:flex;gap:16px;margin-bottom:8px;flex-wrap:wrap}
    .plant-details .detail-item{font-size:13px;color:#666}

  </style> </head><body><div class="header"><div><h1 id="device-id-header" style="margin:0;font-size:15px">üå± Polivalka</h1><div style="font-size:13px">üìç <span id="location-text">‚Äî</span> / <span id="room-text">‚Äî</span><span id="custom-name-suffix"></span></div><div style="font-size:11px;margin-top:4px"><span id="battery-status">üîã ‚Äî</span> ¬∑ <span id="header-state">üí§ Standby</span></div></div><div id="header-warning" style="display:none;flex:1;text-align:center;padding:0 8px"><div style="background:#ff9800;color:#fff;padding:4px 12px;border-radius:12px;font-size:12px;font-weight:600;display:inline-block">‚ö†Ô∏è <span id="warning-text">Warning</span></div></div><div class="header-info"><div id="header-time" class="mono" style="font-size:11px">--:--</div><div style="font-size:11px" id="header-mode"><span id="mode-badge" class="status-badge">‚Äî</span></div><div style="font-size:11px" id="header-conn">üì° <span id="conn-text">Offline</span></div></div></div></div><div class="nav"><a href="/">Fleet</a><a href="home.html" class="active">Home</a><a href="identify.html" style="background:#e8f5e9">üå± Plant</a><a href="timer.html">Timer</a><a href="sensor.html">Sensor</a><a href="settings.html">Settings</a><a href="calibration.html">Calibration</a><a href="online.html">Online</a><a href="trends.html">Trends</a><a href="ota.html">Update</a><a href="admin.html" id="admin-nav-link" style="display:none">Admin</a></div><div class="container"><div id="plant-card" class="card" style="display:none;background:linear-gradient(135deg,#e8f5e9 0%,#fff 100%)">
<!-- Compact row (always visible, click to expand) -->
<div id="plant-row" class="plant-row" onclick="togglePlantExpand()">
<span id="plant-expand-icon" class="expand-icon">‚ñ∂</span>
<img id="plant-image" src="" alt="" style="width:50px;height:50px;border-radius:10px;object-fit:cover;border:2px solid #2c5f2d;display:none">
<div style="flex:1;min-width:0">
<div id="plant-name" style="font-size:16px;font-weight:600;color:#2c5f2d;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">‚Äî</div>
<div id="plant-scientific" style="font-size:12px;color:#666;font-style:italic">‚Äî</div>
</div>
<div style="text-align:right;flex-shrink:0">
<div style="font-size:13px;font-weight:600">üíß <span id="plant-range">35-55%</span></div>
<div style="font-size:11px;color:#666" id="plant-frequency">Every 7-10 days</div>
</div>
</div>
<!-- Expanded details (hidden by default) -->
<div id="plant-details" class="plant-details">
<div id="plant-extra-info" style="font-size:12px;color:#666;margin-bottom:8px"></div>
<div id="plant-warning" style="padding:6px 10px;background:#ffebee;border-radius:6px;font-size:12px;color:#c62828;margin-bottom:8px;display:none"></div>
<div id="plant-description" style="font-size:13px;color:#444;margin-bottom:12px;line-height:1.4"></div>
<div class="detail-row">
<div class="detail-item">üíß Watering: <span id="plant-watering-detail">Every 7-10 days</span></div>
<div class="detail-item">üå°Ô∏è Temperature: <span id="plant-temperature">18-24¬∞C</span></div>
<div class="detail-item">üí® Humidity: <span id="plant-humidity">40-60%</span></div>
</div>
<div style="margin-top:12px">
<a href="identify.html" style="padding:8px 12px;background:#2c5f2d;color:#fff;border-radius:8px;font-size:12px;text-decoration:none">üå± Change Plant</a>
</div>
</div>
</div><div class="card"><h3>üíß Capacitive Sensor (J6)</h3><div class="mono" style="font-size:14px;margin:8px 0" id="sensor-vals">ADC: ‚Äî<br>Moisture: ‚Äî %</div><div class="row"><button onclick="navigateTo('calibration.html')">Calibrate Sensor</button></div></div><div class="card"><h3>üå°Ô∏è Resistive Sensor (J7)</h3><div class="mono" style="font-size:14px;margin:8px 0;color:#9c27b0" id="sensor2-vals">ADC: ‚Äî<br>Moisture: ‚Äî %</div></div><div class="card"><h3>üö∞ Manual Control</h3><div style="display:flex;gap:12px"><div style="flex:1"><div class="row"><label>Duration:</label><input id="manual-duration" type="number" min="1" max="300" value="5" style="width:80px"><select id="manual-unit" style="padding:6px"><option value="sec">seconds</option><option value="min">minutes</option></select></div><div class="row" style="margin-top:10px"><button id="btn-manual" onclick="manualWater()">Water Now</button><button id="btn-stop" onclick="stopPump()" style="background:#b00;color:#fff;border-color:#900" disabled>STOP</button></div><div id="pump-running" style="display:none;margin-top:12px;padding:10px;background:#e8f5e9;border-radius:8px;border:2px solid #2c5f2d"><div style="font-weight:600;color:#2c5f2d">üíß Pump Running</div><div class="mono" style="font-size:13px;margin-top:4px"><span id="pump-elapsed">0s</span> / <span id="pump-total">0s</span><span id="pump-remaining" style="margin-left:8px">(‚Äî)</span></div></div><div class="row" style="margin-top:12px"><button onclick="navigateTo('calibration.html#pump')" style="font-size:12px;padding:6px 10px">Calibrate Pump</button></div></div><div style="display:flex;flex-direction:column;align-items:center;padding:8px 12px;background:#f5f5f5;border-radius:8px;min-width:50px"><div class="muted" style="font-size:11px;margin-bottom:4px">Speed</div><div class="mono" style="font-size:14px;font-weight:600;color:#2c5f2d" id="speed-display">100%</div><input type="range" class="vertical" id="speed-slider" min="0" max="100" value="100" oninput="speedPreview(this.value)" onchange="setSpeed(this.value)" style="margin:8px 0"><div style="display:flex;flex-direction:column;font-size:10px;color:#666;text-align:center"><span>0</span></div></div></div></div><div class="card"><h3>Operating Mode</h3><p class="muted">Select how the system should water your plants</p><div class="mode-selector"><div class="mode-btn" data-mode="manual" onclick="selectMode('manual')"><div class="mode-icon">‚úã</div><div class="mode-name">Manual</div><div class="muted" style="font-size:11px">Manual watering only</div></div><div class="mode-btn" data-mode="timer" onclick="selectMode('timer')"><div class="mode-icon">‚è∞</div><div class="mode-name">Timer</div><div class="muted" style="font-size:11px">Schedule-based</div></div><div class="mode-btn" data-mode="sensor" onclick="selectMode('sensor')"><div class="mode-icon">üíß</div><div class="mode-name">Sensor</div><div class="muted" style="font-size:11px">Moisture-based</div></div></div><p class="muted" style="margin-top:12px;font-size:12px"> ‚ÑπÔ∏è Configure schedules on <b>Timer</b> page, sensor settings on <b>Sensor</b> page, and calibration on <b>Calibration</b> page.</p></div><div class="card" style="padding:12px"><h3 style="margin-top:0">System Status</h3><div style="display:flex;gap:16px;flex-wrap:wrap;margin-bottom:12px"><div style="flex:1;min-width:100px"><div class="muted" style="font-size:12px">State</div><div id="current-state" class="mono" style="font-size:14px">‚Äî</div></div><div style="flex:1;min-width:100px"><div class="muted" style="font-size:12px">Mode</div><div id="current-mode" style="font-size:14px">‚Äî</div></div><div style="flex:1;min-width:120px"><div class="muted" style="font-size:12px">Last Watering</div><div id="last-watering" class="mono" style="font-size:14px">‚Äî</div></div></div><div id="sensor-status-details" style="display:none;border-top:1px solid #ddd;padding-top:12px;margin-top:4px"><div style="display:flex;gap:16px;flex-wrap:wrap;margin-bottom:8px"><div style="flex:1;min-width:100px"><div class="muted" style="font-size:12px">Current Moisture</div><div id="status-current-moisture" class="mono" style="font-size:14px">‚Äî</div></div><div style="flex:1;min-width:100px"><div class="muted" style="font-size:12px">Target Range</div><div id="status-target-range" class="mono" style="font-size:14px">‚Äî</div></div><div style="flex:1;min-width:120px"><div class="muted" style="font-size:12px">Daily Water</div><div id="status-daily-water" class="mono" style="font-size:14px">‚Äî</div></div></div><div id="status-progress-row" style="display:none;margin-bottom:8px"><div class="muted" style="font-size:12px">Watering Progress</div><div id="status-watering-progress" class="mono" style="font-size:14px">‚Äî</div></div><div id="status-warning-row" style="display:none;padding:8px;background:#fff3cd;border-radius:8px;border:1px solid #ffc107"><div style="font-weight:600;color:#856404">‚ö†Ô∏è Warning</div><div id="status-warning-message" style="font-size:13px;color:#856404;margin-top:4px">‚Äî</div></div></div><div id="timer-status-details" style="display:none;border-top:1px solid #ddd;padding-top:12px;margin-top:4px"><div style="display:flex;gap:16px;flex-wrap:wrap;margin-bottom:8px"><div style="flex:1;min-width:100px"><div class="muted" style="font-size:12px">Next Watering</div><div id="status-next-watering" class="mono" style="font-size:14px">‚Äî</div></div><div style="flex:1;min-width:100px"><div class="muted" style="font-size:12px">Schedules</div><div id="status-schedule-count" class="mono" style="font-size:14px">‚Äî</div></div><div style="flex:1;min-width:120px"><div class="muted" style="font-size:12px">Daily Water</div><div id="timer-daily-water" class="mono" style="font-size:14px">‚Äî</div></div></div><div id="timer-watering-row" style="display:none;margin-bottom:8px"><div class="muted" style="font-size:12px">Watering Duration</div><div id="timer-watering-duration" class="mono" style="font-size:14px">‚Äî</div></div><div id="timer-warning-row" style="display:none;padding:8px;background:#fff3cd;border-radius:8px;border:1px solid #ffc107"><div style="font-weight:600;color:#856404">‚ö†Ô∏è Warning</div><div id="timer-warning-message" style="font-size:13px;color:#856404;margin-top:4px">‚Äî</div></div></div></div><div class="card"><h3>Automation Control</h3><p class="muted" id="auto-instruction">Select Timer or Sensor mode to enable automation</p><div id="timer-auto-control" style="display:none;margin-top:12px"><div class="toggle-row" id="timer-toggle-row" style="visibility:hidden"><div><div style="font-weight:600">Timer Auto Watering</div><div class="muted" style="font-size:12px">Schedule-based automatic watering</div></div><label class="toggle-switch"><input type="checkbox" id="timer-auto-toggle" onchange="toggleTimerAuto(this.checked)"><span class="toggle-slider"></span></label></div><div id="timer-arming-cancel-section" style="display:none;margin-top:12px;padding:12px;background:#fff3e0;border-radius:8px;border:2px solid #f57c00"><div style="display:flex;justify-content:space-between;align-items:center"><div><div style="font-weight:600;color:#e65100">‚è∞ Timer Countdown</div><div class="muted" style="font-size:13px;margin-top:4px">Timer mode starting in <span id="timer-arming-countdown-display" style="font-weight:600">15</span> seconds...</div></div><button onclick="cancelTimerArming()" style="background:#b00;color:#fff;border-color:#900;padding:8px 16px;font-weight:600">CANCEL</button></div></div><p class="muted" style="margin-top:8px;font-size:12px"> ‚ö†Ô∏è Before enabling: make sure pump and delivery tubes are properly connected! </p></div><div id="sensor-auto-control" style="display:none;margin-top:12px"><div class="toggle-row" id="sensor-toggle-row" style="visibility:hidden"><div><div style="font-weight:600">Sensor Auto Watering</div><div class="muted" style="font-size:12px">Moisture-based automatic watering</div></div><label class="toggle-switch"><input type="checkbox" id="sensor-auto-toggle" onchange="toggleSensorAuto(this.checked)"><span class="toggle-slider"></span></label></div><div id="arming-cancel-section" style="display:none;margin-top:12px;padding:12px;background:#fff3e0;border-radius:8px;border:2px solid #f57c00"><div style="display:flex;justify-content:space-between;align-items:center"><div><div style="font-weight:600;color:#e65100">üöÄ Launch Countdown</div><div class="muted" style="font-size:13px;margin-top:4px">Sensor mode starting in <span id="arming-countdown-display" style="font-weight:600">60</span> seconds...</div></div><button onclick="cancelArming()" style="background:#b00;color:#fff;border-color:#900;padding:8px 16px;font-weight:600">CANCEL</button></div></div><p class="muted" style="margin-top:8px;font-size:12px"> ‚ö†Ô∏è Before enabling: make sure sensor is inserted in soil and calibrated! </p></div></div></div> <script>
// Admin nav link, sleep(), mapStateToDisplay(), navigateTo() - moved to common.js

// ============ Toxic Plant Families (Source: ASPCA Poison Control) ============
// Format: CAUSE ‚Üí EFFECT ‚Üí ACTION
const TOXIC_FAMILIES = {
  'Araliaceae': { pets: true, humans: true, note: 'Sap on skin ‚Üí rash. Pet eats leaf ‚Üí vomiting. Wash hands after pruning' },
  'Araceae': { pets: true, humans: true, note: 'Chewing ‚Üí mouth/throat swelling, drooling. Severe swelling ‚Üí vet' },
  'Liliaceae': { pets: true, humans: false, note: 'üö® CATS: pollen/leaf contact ‚Üí kidney failure in 24-72h. Any contact ‚Üí vet immediately' },
  'Solanaceae': { pets: true, humans: false, note: 'Ripe fruit = safe. Green leaves/stems ‚Üí pet vomiting. Keep unripe away from pets' },
  'Amaryllidaceae': { pets: true, humans: true, note: 'Bulb most toxic. Pet chews bulb ‚Üí vomiting, tremors. Keep bulbs buried or out of reach' },
  'Apocynaceae': { pets: true, humans: true, note: 'Any part eaten ‚Üí heart rhythm problems. Even small amount ‚Üí vet' },
  'Crassulaceae': { pets: true, humans: false, note: 'Pet eats ‚Üí vomiting, diarrhea. Humans safe to handle' },
  'Ericaceae': { pets: true, humans: true, note: 'Any part eaten ‚Üí vomiting, weakness, heart issues. Keep away from pets' },
  'Euphorbiaceae': { pets: true, humans: true, note: 'Milky sap on skin ‚Üí irritation. In eyes ‚Üí rinse 15 min. Wear gloves when pruning' },
  'Cycadaceae': { pets: true, humans: true, note: 'üö® Seeds eaten ‚Üí liver failure. Dogs love to chew them. Any ingestion ‚Üí vet immediately' },
  'Zamiaceae': { pets: true, humans: true, note: 'üö® Seeds eaten ‚Üí liver failure. Dogs love to chew them. Any ingestion ‚Üí vet immediately' },
  'Ranunculaceae': { pets: true, humans: true, note: 'Sap on skin ‚Üí blisters. Eaten ‚Üí mouth pain, vomiting. Wear gloves' },
  'Plantaginaceae': { pets: true, humans: true, note: 'üö® Any amount eaten ‚Üí heart rhythm problems. Keep away from children and pets' },
  'Asteraceae': { pets: true, humans: false, note: 'Pet eats ‚Üí skin irritation, vomiting. Humans safe' },
  'Moraceae': { pets: true, humans: true, note: 'Sap on skin ‚Üí rash. Pet eats leaf ‚Üí vomiting. Wash hands after pruning' },
  'Asparagaceae': { pets: true, humans: false, note: 'Pet eats berries ‚Üí vomiting, diarrhea. Keep berries away from pets' }
};

// –§–ª–∞–≥–∏ –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è —Ä–µ–∫—É—Ä—Å–∏–∏ –ø—Ä–∏ –ø—Ä–æ–≥—Ä–∞–º–º–Ω–æ–º –∏–∑–º–µ–Ω–µ–Ω–∏–∏ toggles
let updatingTimerToggle = false;
let updatingSensorToggle = false;

// Block toggle sync while command is being processed (prevents bounce)
let sensorCommandPending = false;
let timerCommandPending = false;

// Track sensor disconnection state (ADC < 100 = not connected)
let sensor1Disconnected = false;
let sensor2Disconnected = false;

// –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏–π –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–æ–≤ (–¥–ª—è badge –∏–Ω–¥–∏–∫–∞—Ü–∏–∏)
let lastSensorState = 'DISABLED';
let lastTimerState = 'DISABLED';

// Cloud mode: –ª–æ–∫–∞–ª—å–Ω—ã–π countdown (ESP32 –Ω–µ —à–ª—ë—Ç countdown –∫–∞–∂–¥—É—é —Å–µ–∫—É–Ω–¥—É - —ç–∫–æ–Ω–æ–º–∏—è)
let sensorLaunchStartTime = null;  // timestamp –∫–æ–≥–¥–∞ —É–≤–∏–¥–µ–ª–∏ LAUNCH
let timerLaunchStartTime = null;
const SENSOR_LAUNCH_DURATION = 60;  // —Å–µ–∫—É–Ω–¥
const TIMER_LAUNCH_DURATION = 15;   // —Å–µ–∫—É–Ω–¥

// –õ–æ–∫–∞–ª—å–Ω—ã–π countdown ticker –¥–ª—è Cloud mode
if (IS_CLOUD) {
  setInterval(() => {
    // Sensor countdown
    if (lastSensorState === 'LAUNCH' && sensorLaunchStartTime) {
      const elapsed = Math.floor((Date.now() - sensorLaunchStartTime) / 1000);
      const remaining = Math.max(0, SENSOR_LAUNCH_DURATION - elapsed);
      document.getElementById('arming-countdown-display').textContent = remaining;
      const stateEl = document.getElementById('current-state');
      if (stateEl) {
        if (remaining > 0) {
          stateEl.innerHTML = `üöÄ LAUNCH IN ${remaining}s`;
        } else {
          stateEl.innerHTML = `üöÄ Starting...`;
        }
      }
    }
    // Timer countdown
    if (lastTimerState === 'LAUNCH' && timerLaunchStartTime) {
      const elapsed = Math.floor((Date.now() - timerLaunchStartTime) / 1000);
      const remaining = Math.max(0, TIMER_LAUNCH_DURATION - elapsed);
      document.getElementById('timer-arming-countdown-display').textContent = remaining;
      const stateEl = document.getElementById('current-state');
      if (stateEl) {
        if (remaining > 0) {
          stateEl.textContent = `‚è∞ LAUNCH ${remaining}s`;
        } else {
          stateEl.textContent = `‚è∞ Starting...`;
        }
      }
    }
  }, 1000);
}

async function updateStatus(){
  try {
    const s = await API.get('/status');

    // Cloud mode: update battery from /status (time handled by common.js)
    if (IS_CLOUD) {
      // Time is handled by universal clock in common.js

      // Battery: from /status response (3 states only)
      // 1. üîã XX% - battery, not charging
      // 2. üîã XX% ‚ö° - battery, charging
      // 3. ‚ö° AC - no battery, AC power
      // percent < 0 means "no battery detected" (ESP32 returns -1.0)
      const batteryStatus = document.getElementById('battery-status');
      if (s.battery && s.battery.percent !== null && s.battery.percent !== undefined && s.battery.percent >= 0) {
        const percent = Math.round(s.battery.percent);
        const charging = s.battery.charging ? ' ‚ö°' : '';
        batteryStatus.textContent = `üîã ${percent}%${charging}`;
      } else {
        batteryStatus.textContent = '‚ö° AC';
      }
    }

    // Device ID header (first line) - show full device ID from DEVICE_ID or ESP32
    // Custom name goes in second line suffix if different from device_id
    if (IS_CLOUD && DEVICE_ID) {
      document.getElementById('device-id-header').textContent = 'üå± ' + DEVICE_ID;
    } else if (s.system_state?.device_name) {
      // AP mode - use device name from ESP32
      document.getElementById('device-id-header').textContent = 'üå± ' + s.system_state.device_name;
    }

    // Location and Room
    if (s.system_state?.location) {
      document.getElementById('location-text').textContent = s.system_state.location;
    }
    if (s.system_state?.room) {
      document.getElementById('room-text').textContent = s.system_state.room;
    }

    // Custom name suffix (always show device name, default to Plant)
    let customName = s.system_state?.device_name || 'Plant';
    // Replace default names with "Plant"
    if (customName === 'Polivalka' || customName.toLowerCase().startsWith('polivalka-')) {
      customName = 'Plant';
    }
    document.getElementById('custom-name-suffix').textContent = ' / ' + customName;

    // Sensor data (Capacitive - primary sensor) - use float for 0.1% precision
    // Check both undefined AND null (API returns null when data missing in DynamoDB)
    const moisturePct = (s.percent_float !== undefined && s.percent_float !== null)
      ? s.percent_float.toFixed(1)
      : (s.percent !== null && s.percent !== undefined ? s.percent : '‚Äî');
    // Check if sensor is disconnected (ADC < 100 = not connected) - update global state
    sensor1Disconnected = (s.adc !== null && s.adc !== undefined && s.adc < 100);
    const sensor1Warning = sensor1Disconnected ? '<br><span style="color:#e65100;font-size:12px">‚ö†Ô∏è Sensor not connected</span>' : '';
    document.getElementById('sensor-vals').innerHTML =
      `ADC: ${s.adc !== null && s.adc !== undefined ? s.adc : '‚Äî'}<br>Moisture: ${moisturePct} %${sensor1Warning}`;
    // Hide auto-watering warning when sensor is connected
    if (!sensor1Disconnected) {
      hideSensorDisconnectedWarning();
    }

    // Sensor 2 data (Resistive) - use float for 0.1% precision
    if (s.sensor2_adc !== undefined && s.sensor2_adc !== null) {
      const pct2 = (s.sensor2_percent_float !== undefined && s.sensor2_percent_float !== null)
        ? s.sensor2_percent_float.toFixed(1)
        : (s.sensor2_percent !== undefined && s.sensor2_percent !== null ? s.sensor2_percent : '‚Äî');
      sensor2Disconnected = (s.sensor2_adc < 100);
      const sensor2Warning = sensor2Disconnected ? '<br><span style="color:#e65100;font-size:12px">‚ö†Ô∏è Sensor not connected</span>' : '';
      document.getElementById('sensor2-vals').innerHTML = `ADC: ${s.sensor2_adc}<br>Moisture: ${pct2} %${sensor2Warning}`;
    }

    // System State (–≤ System Status card, –Ω–µ –≤ header!)
    // Map internal state to user-friendly: Standby/Watering/Emergency
    const rawState = s.system_state?.state || 'OFF';
    const displayState = mapStateToDisplay(rawState, s.pump_running);
    const stateEl = document.getElementById('current-state');
    stateEl.innerHTML = `${displayState.emoji} ${displayState.text}`;
    stateEl.style.color = displayState.color;

    // Update header state (alongside battery)
    const headerStateEl = document.getElementById('header-state');
    if (headerStateEl) {
      headerStateEl.textContent = `${displayState.emoji} ${displayState.text}`;
    }

    // Mode badge —Å —É—á—ë—Ç–æ–º state –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–∞
    const mode = s.system_state?.mode || 'off';
    const modeBadge = document.getElementById('mode-badge');
    const modeText = mode.charAt(0).toUpperCase() + mode.slice(1);
    modeBadge.textContent = modeText;

    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∫–ª–∞—Å—Å badge –Ω–∞ –æ—Å–Ω–æ–≤–µ state –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–∞
    let badgeClass = 'status-badge';
    if (mode === 'sensor') {
      if (lastSensorState === 'LAUNCH') {
        badgeClass += ' status-launch'; // –ú–∏–≥–∞—é—â–∏–π –æ—Ä–∞–Ω–∂–µ–≤—ã–π
      } else if (lastSensorState !== 'DISABLED') {
        badgeClass += ' status-active'; // –ì–æ–ª—É–±–æ–π (STANDBY, PULSE, SETTLE, CHECK, COOLDOWN)
      } else {
        badgeClass += ' status-sensor'; // –û–±—ã—á–Ω—ã–π sensor (–æ—Ä–∞–Ω–∂–µ–≤—ã–π)
      }
    } else if (mode === 'timer') {
      if (lastTimerState === 'LAUNCH') {
        badgeClass += ' status-launch'; // –ú–∏–≥–∞—é—â–∏–π –æ—Ä–∞–Ω–∂–µ–≤—ã–π
      } else if (lastTimerState === 'ACTIVE' || lastTimerState === 'WATERING') {
        badgeClass += ' status-active'; // –ì–æ–ª—É–±–æ–π (ACTIVE, WATERING)
      } else {
        badgeClass += ' status-timer'; // –û–±—ã—á–Ω—ã–π timer (–≥–æ–ª—É–±–æ–π)
      }
    } else {
      badgeClass += ' status-off'; // –°–µ—Ä—ã–π (OFF)
    }
    modeBadge.className = badgeClass;

    document.getElementById('current-mode').textContent = modeText;

    // Connection status
    const connText = document.getElementById('conn-text');
    if (s.wifi_connected) {
      connText.textContent = 'Online';
      connText.style.color = '#fff';
    } else {
      connText.textContent = 'Offline';
      connText.style.color = '#999';
    }

    // Mode selector - highlight current mode
    document.querySelectorAll('.mode-btn').forEach(btn => {
      btn.classList.toggle('selected', btn.dataset.mode === mode);
    });

    // Last watering
    if (s.system_state?.last_watering) {
      document.getElementById('last-watering').textContent = s.system_state.last_watering;
    }

    // Pump Running Indicator
    const pumpIndicator = document.getElementById('pump-running');
    const stopBtn = document.getElementById('btn-stop');
    const manualBtn = document.getElementById('btn-manual');

    // Cloud mode: Don't override pump UI if local countdown is active (optimistic update)
    // The local countdown provides instant feedback while we wait for telemetry update
    const localCountdownActive = IS_CLOUD && window.pumpCountdownInterval;

    if (s.pump_running) {
      pumpIndicator.style.display = 'block';
      stopBtn.disabled = false;

      // Disable manual button while pump is running
      manualBtn.disabled = true;
      manualBtn.style.background = '#ccc';
      manualBtn.style.borderColor = '#aaa';

      // Only update from server data if no local countdown (prevents flicker)
      if (!localCountdownActive) {
        const elapsedSec = Math.floor(s.pump_elapsed_ms / 1000);
        const totalSec = s.pump_remaining_ms > 0 ? Math.floor((s.pump_elapsed_ms + s.pump_remaining_ms) / 1000) : elapsedSec;
        const remainingSec = s.pump_remaining_ms > 0 ? Math.floor(s.pump_remaining_ms / 1000) : 0;

        // Show elapsed timer as button text
        manualBtn.textContent = `Watering ${elapsedSec}s`;

        document.getElementById('pump-elapsed').textContent = elapsedSec + 's';
        document.getElementById('pump-total').textContent = totalSec + 's';
        document.getElementById('pump-remaining').textContent = s.pump_remaining_ms > 0 ? `(${remainingSec}s left)` : '(manual mode)';
      }
    } else {
      // Pump NOT running according to server - always trust server state
      // Clear local countdown if still running (pump stopped on ESP32 side)
      if (localCountdownActive) {
        clearInterval(window.pumpCountdownInterval);
        window.pumpCountdownInterval = null;
      }

      // Reset UI
      pumpIndicator.style.display = 'none';
      stopBtn.disabled = true;

      // Re-enable manual button when pump stops
      manualBtn.disabled = false;
      manualBtn.textContent = 'Water Now';
      manualBtn.style.background = '';
      manualBtn.style.borderColor = '';
    }

    // Automation Control - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –Ω—É–∂–Ω—É—é —Å–µ–∫—Ü–∏—é
    const timerControl = document.getElementById('timer-auto-control');
    const sensorControl = document.getElementById('sensor-auto-control');
    const instruction = document.getElementById('auto-instruction');

    if (mode === 'timer') {
      timerControl.style.display = 'block';
      sensorControl.style.display = 'none';
      instruction.style.display = 'none';

      // NOTE: Toggle state will be updated by updateTimerControllerStatus()
      // based on actual timer_controller state (not just mode)
    } else if (mode === 'sensor') {
      timerControl.style.display = 'none';
      sensorControl.style.display = 'block';
      instruction.style.display = 'none';

      // NOTE: Toggle state will be updated by updateSensorControllerStatus()
      // based on actual sensor_controller state (not just mode)
    } else {
      timerControl.style.display = 'none';
      sensorControl.style.display = 'none';
      instruction.style.display = 'block';
    }
  } catch(e) {
    // Suppress noisy network errors (ERR_INTERNET_DISCONNECTED, Failed to fetch)
    if (!e.message?.includes('fetch')) {
      console.error('Status update failed:', e);
    }
  }
}

async function updateTime(){
  try {
    const t = await API.get('/time/status');
    const timeEl = document.getElementById('header-time');
    if (t.time_set && t.current_time) {
      timeEl.textContent=t.current_time.substring(11,16);
      timeEl.className = 'mono';
    } else {
      timeEl.textContent = '--:--';
      timeEl.className = 'mono danger';
    }
  } catch(e) {
    console.error('Time update failed:', e);
  }
}

async function updateBattery(){
  try {
    const b = await API.get('/battery/status');
    const batteryStatus = document.getElementById('battery-status');

    // 3 states only:
    // 1. üîã XX% - battery, not charging
    // 2. üîã XX% ‚ö° - battery, charging
    // 3. ‚ö° AC - no battery, AC power
    // percent < 0 means "no battery detected" (ESP32 returns -1.0)
    if (b.percent !== null && b.percent !== undefined && b.percent >= 0) {
      const percent = Math.round(b.percent);
      const charging = b.charging ? ' ‚ö°' : '';
      batteryStatus.textContent = `üîã ${percent}%${charging}`;
    } else {
      batteryStatus.textContent = '‚ö° AC';
    }
  } catch(e) {
    document.getElementById('battery-status').textContent = '‚ö° AC';
  }
}

async function selectMode(mode) {
  try {
    // Check if switching away from active controller
    const currentMode = document.querySelector('.mode-btn.selected')?.getAttribute('data-mode');

    if (currentMode === 'timer' && lastTimerState !== 'DISABLED' && mode !== 'timer') {
      if (!confirm('‚ö†Ô∏è Timer automation is active!\n\nSwitching mode will disable it.\nYou will need to re-enable automation after switching back.\n\nContinue?')) {
        return; // User cancelled
      }
    }

    if (currentMode === 'sensor' && lastSensorState !== 'DISABLED' && mode !== 'sensor') {
      if (!confirm('‚ö†Ô∏è Sensor automation is active!\n\nSwitching mode will disable it.\nYou will need to re-enable automation after switching back.\n\nContinue?')) {
        return; // User cancelled
      }
    }

    // Optimistic UI update - immediately show selected mode
    document.querySelectorAll('.mode-btn').forEach(btn => {
      btn.classList.toggle('selected', btn.dataset.mode === mode);
    });
    document.getElementById('current-mode').textContent = mode.charAt(0).toUpperCase() + mode.slice(1);
    const modeBadge = document.getElementById('mode-badge');
    modeBadge.textContent = mode.charAt(0).toUpperCase() + mode.slice(1);
    modeBadge.className = 'status-badge status-' + mode;

    await API.post('/mode', {mode: mode});

    // Cloud mode: wait for MQTT to propagate, then refresh
    if (IS_CLOUD) {
      await sleep(2000);
    }
    updateStatus();
    updateControllerStatus();
  } catch(e) {
    alert('Error setting mode: ' + e.message);
    // Revert optimistic update on error
    updateStatus();
  }
}

async function manualWater(){
  const duration = parseInt(document.getElementById('manual-duration').value);
  const unit = document.getElementById('manual-unit').value;
  const sec = unit === 'min' ? duration * 60 : duration;

  const btn = document.getElementById('btn-manual');
  const stopBtn = document.getElementById('btn-stop');
  const pumpIndicator = document.getElementById('pump-running');

  btn.disabled = true;
  btn.textContent = 'Starting...';
  btn.style.background = '#ccc';

  try {
    await API.post('/pump?sec=' + sec);

    // Cloud mode: Optimistic UI update (MQTT command sent, show pump running immediately)
    // ESP32 will execute the command, but telemetry update takes 2-3 min
    if (IS_CLOUD) {
      // Show pump running indicator immediately
      pumpIndicator.style.display = 'block';
      stopBtn.disabled = false;
      btn.textContent = `Watering ${sec}s`;

      // Set up local countdown display
      document.getElementById('pump-elapsed').textContent = '0s';
      document.getElementById('pump-total').textContent = sec + 's';
      document.getElementById('pump-remaining').textContent = `(${sec}s left)`;

      // Start local countdown timer for Cloud mode
      let elapsed = 0;
      const countdownInterval = setInterval(() => {
        elapsed++;
        const remaining = Math.max(0, sec - elapsed);
        document.getElementById('pump-elapsed').textContent = elapsed + 's';
        document.getElementById('pump-remaining').textContent = `(${remaining}s left)`;
        btn.textContent = `Watering ${elapsed}s`;

        if (elapsed >= sec) {
          clearInterval(countdownInterval);
          // Pump finished - reset UI
          pumpIndicator.style.display = 'none';
          stopBtn.disabled = true;
          btn.disabled = false;
          btn.textContent = 'Water Now';
          btn.style.background = '';
          btn.style.borderColor = '';
        }
      }, 1000);

      // Store interval ID so STOP can clear it
      window.pumpCountdownInterval = countdownInterval;
    } else {
      // Local mode: ESP32 responds immediately
      updateStatus();
    }
  } catch(e) {
    alert('Error: ' + e.message);
    btn.disabled = false;
    btn.textContent = 'Water Now';
    btn.style.background = '';
  }
}

async function toggleTimerAuto(checked){
  // Ignore programmatic changes
  if (updatingTimerToggle) return;

  try {
    if (checked) {
      // Enable timer controller (starts LAUNCH countdown)
      const resp = await API.post('/timer/controller/enable');
      if (!resp.success) {
        alert(resp.message || 'Failed to enable timer controller');
        document.getElementById('timer-auto-toggle').checked = false;
        return;
      }
      // In Cloud mode, wait for ESP32 to publish updated telemetry
      if (IS_CLOUD) await sleep(2000);
    } else {
      // Disable timer controller (but keep mode as timer)
      await API.post('/timer/controller/disable');
      // In Cloud mode, wait for ESP32 to publish updated telemetry
      if (IS_CLOUD) await sleep(2000);
    }
    updateStatus();
    updateControllerStatus(); // Update UI
  } catch(e) {
    alert('Error: ' + e.message);
    document.getElementById('timer-auto-toggle').checked = !checked; // revert on error
  }
}

// Show sensor disconnection warning in auto-watering section
function showSensorDisconnectedWarning() {
  let warningEl = document.getElementById('sensor-disconnect-warning');
  if (!warningEl) {
    // Create warning element if it doesn't exist
    warningEl = document.createElement('div');
    warningEl.id = 'sensor-disconnect-warning';
    warningEl.style.cssText = 'margin-top:12px;padding:10px;background:#ffebee;border-radius:8px;border:2px solid #c00;color:#b00;font-size:13px';
    warningEl.innerHTML = '<b>‚ö†Ô∏è Sensor not connected!</b><br>Connect the capacitive sensor (J6) before enabling auto watering. ADC must be > 100.';
    // Insert before the "Before enabling" hint
    const sensorControl = document.getElementById('sensor-auto-control');
    if (sensorControl) {
      sensorControl.appendChild(warningEl);
    }
  }
  warningEl.style.display = 'block';
}

// Hide sensor disconnection warning when sensor is connected
function hideSensorDisconnectedWarning() {
  const warningEl = document.getElementById('sensor-disconnect-warning');
  if (warningEl) {
    warningEl.style.display = 'none';
  }
}

async function toggleSensorAuto(checked){
  // Ignore programmatic changes
  if (updatingSensorToggle) return;

  // Block if sensor is disconnected - show inline warning instead of alert
  if (checked && sensor1Disconnected) {
    showSensorDisconnectedWarning();
    document.getElementById('sensor-auto-toggle').checked = false;
    return;
  }

  // Block toggle sync while command is processing (prevents bounce)
  sensorCommandPending = true;

  try {
    if (checked) {
      // Enable sensor controller (starts LAUNCH countdown)
      const resp = await API.post('/sensor/controller/enable');
      if (!resp.success) {
        alert(resp.message || 'Failed to enable sensor controller');
        document.getElementById('sensor-auto-toggle').checked = false;
        sensorCommandPending = false;
        return;
      }
      // In Cloud mode, wait for ESP32 to publish updated telemetry
      if (IS_CLOUD) await sleep(3000);  // Increased to 3s for reliability
    } else {
      // Disable sensor controller (but keep mode as sensor)
      await API.post('/sensor/controller/disable');
      // In Cloud mode, wait for ESP32 to publish updated telemetry
      if (IS_CLOUD) await sleep(3000);
    }
    updateStatus();
    updateControllerStatus(); // Update UI
  } catch(e) {
    alert('Error: ' + e.message);
    document.getElementById('sensor-auto-toggle').checked = !checked; // revert on error
  } finally {
    sensorCommandPending = false;
  }
}

async function stopPump(){
  const btn = document.getElementById('btn-manual');
  const stopBtn = document.getElementById('btn-stop');
  const pumpIndicator = document.getElementById('pump-running');

  stopBtn.disabled = true;
  stopBtn.textContent = 'Stopping...';

  try {
    await API.post('/pump/stop');

    // Cloud mode: Optimistic UI update
    if (IS_CLOUD) {
      // Clear the countdown timer if running
      if (window.pumpCountdownInterval) {
        clearInterval(window.pumpCountdownInterval);
        window.pumpCountdownInterval = null;
      }

      // Reset UI immediately
      pumpIndicator.style.display = 'none';
      btn.disabled = false;
      btn.textContent = 'Water Now';
      btn.style.background = '';
      btn.style.borderColor = '';
    } else {
      // Local mode: ESP32 responds immediately
      updateStatus();
    }

    // Reset STOP button
    stopBtn.textContent = 'STOP';
  } catch(e) {
    alert('Error: ' + e.message);
    stopBtn.disabled = false;
    stopBtn.textContent = 'STOP';
  }
}

async function cancelArming(){
  try {
    const resp = await API.post('/sensor/controller/cancel');
    if (resp.success) {
      // Also disable the toggle
      document.getElementById('sensor-auto-toggle').checked = false;
      updateStatus();
      updateControllerStatus(); // Use unified update instead
    } else {
      alert(resp.message || 'Failed to cancel launch');
    }
  } catch(e) {
    alert('Error: ' + e.message);
  }
}

// monitorWiFiMode() - moved to common.js

// Smart polling: different intervals for Cloud vs Local
// Cloud: 60 sec (data updates hourly from device, no point polling faster)
// Local: 5 sec (ESP32 is local, fast feedback needed for pump control)
// CRITICAL: Stop polling when tab is hidden (saves API Gateway costs!)
const STATUS_INTERVAL = IS_CLOUD ? 60000 : 5000;
let statusIntervalId = null;
let localIntervalsStarted = false;

function startPolling() {
  if (statusIntervalId) return; // Already polling
  statusIntervalId = setInterval(updateStatus, STATUS_INTERVAL);

  // Time/Battery/WiFi monitoring —Ç–æ–ª—å–∫–æ –≤ –ª–æ–∫–∞–ª—å–Ω–æ–º —Ä–µ–∂–∏–º–µ
  if (!IS_CLOUD && !localIntervalsStarted) {
    localIntervalsStarted = true;
    setInterval(updateTime, 60000);    // –∫–∞–∂–¥—ã–µ 60 —Å–µ–∫
    setInterval(updateBattery, 10000); // –∫–∞–∂–¥—ã–µ 10 —Å–µ–∫
    setInterval(monitorWiFiMode, 5000); // –∫–∞–∂–¥—ã–µ 5 —Å–µ–∫
  }
}

function stopPolling() {
  if (statusIntervalId) {
    clearInterval(statusIntervalId);
    statusIntervalId = null;
  }
}

// Visibility change: pause polling when tab is hidden
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    stopPolling();
    console.log('Tab hidden - polling paused');
  } else {
    updateStatus(); // Immediate update when tab becomes visible
    startPolling();
    console.log('Tab visible - polling resumed');
  }
});

// Start polling
startPolling();

// Cloud mode: –ø–æ–∫–∞–∑–∞—Ç—å device ID –≤ header —Å—Ä–∞–∑—É (–¥–æ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö –∏–∑ API)
if (IS_CLOUD && DEVICE_ID) {
  document.getElementById('device-id-header').textContent = 'üå± ' + DEVICE_ID;
  document.title = `${DEVICE_ID} ‚Äî Home`;
} else if (IS_CLOUD && !DEVICE_ID) {
  // ERROR: Cloud mode requires device_id parameter
  document.body.innerHTML = `
    <div style="display:flex;flex-direction:column;align-items:center;justify-content:center;height:100vh;text-align:center;padding:20px">
      <h1 style="color:#b00">‚ö†Ô∏è Missing Device ID</h1>
      <p style="font-size:16px;color:#666;max-width:500px">
        This page requires a device ID parameter to work in cloud mode.<br>
        Please select a device from the fleet page.
      </p>
      <a href="/" style="display:inline-block;margin-top:20px;padding:12px 24px;background:#2c5f2d;color:#fff;text-decoration:none;border-radius:8px;font-weight:600">
        ‚Üê Go to Fleet
      </a>
      <p style="margin-top:40px;font-size:13px;color:#999">
        Expected URL format: home.html?device=Polivalka-BB00C1
      </p>
    </div>
  `;
  throw new Error('Missing device_id parameter in cloud mode');
}

// –ü–µ—Ä–≤–∞—è –∑–∞–≥—Ä—É–∑–∫–∞: –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ —Å –∑–∞–¥–µ—Ä–∂–∫–∞–º–∏
updateStatus();

// Time/Battery/WiFi —Ç–æ–ª—å–∫–æ –¥–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —Ä–µ–∂–∏–º–∞
if (!IS_CLOUD) {
  setTimeout(() => updateTime(), 500);     // —á–µ—Ä–µ–∑ 0.5 —Å–µ–∫
  setTimeout(() => updateBattery(), 1000); // —á–µ—Ä–µ–∑ 1 —Å–µ–∫
  setTimeout(() => monitorWiFiMode(), 1500); // —á–µ—Ä–µ–∑ 1.5 —Å–µ–∫
}

// Sensor Controller Status (for Sensor mode)
var sensorPresetCache = null;

async function updateSensorControllerStatus() {
  try {
    const mode = document.querySelector('.mode-btn.selected')?.getAttribute('data-mode');

    // Hide sensor details if not in sensor mode
    const detailsSection = document.getElementById('sensor-status-details');
    if (mode !== 'sensor') {
      detailsSection.style.display = 'none';
      document.getElementById('header-warning').style.display = 'none';
      return;
    }

    // Fetch sensor controller status
    const sc = await API.get('/sensor/controller/status');

    // Save state globally for badge indication
    // Cloud mode: track LAUNCH start time for local countdown
    if (IS_CLOUD && sc.state === 'LAUNCH' && lastSensorState !== 'LAUNCH') {
      sensorLaunchStartTime = Date.now();  // Just entered LAUNCH
    } else if (sc.state !== 'LAUNCH') {
      sensorLaunchStartTime = null;  // Exited LAUNCH
    }
    lastSensorState = sc.state;

    // Fetch preset config (cache for 10 seconds to reduce load)
    if (!sensorPresetCache || Date.now() - sensorPresetCache.timestamp > 10000) {
      const preset = await API.get('/sensor/preset');
      sensorPresetCache = {data: preset, timestamp: Date.now()};
    }
    const preset = sensorPresetCache.data;

    // Show sensor details section
    detailsSection.style.display = 'block';

    // Only update State field if we're actually in sensor mode!
    if (mode === 'sensor') {
      const stateEl = document.getElementById('current-state');
      let stateText = sc.state;
      let stateColor = '#333';

      if (sc.state === 'LAUNCH') {
        stateText = `üöÄ LAUNCH IN ${sc.arming_countdown}s`;
        stateColor = '#f57c00';
      } else if (sc.state === 'STANDBY') {
        stateText = 'üëÄ Monitoring';
        stateColor = '#2c5f2d';
      } else if (sc.state === 'PULSE') {
        stateText = 'üíß Watering';
        stateColor = '#1976d2';
      } else if (sc.state === 'SETTLE') {
        stateText = '‚è≥ Absorbing';
        stateColor = '#9c27b0';
      } else if (sc.state === 'CHECK') {
        stateText = 'üîç Checking';
        stateColor = '#ff9800';
      } else if (sc.state === 'COOLDOWN') {
        const cooldownMin = Math.floor(sc.cooldown_remaining / 60);
        stateText = `üò¥ Resting (${cooldownMin}m)`;
        stateColor = '#607d8b';
      } else if (sc.state === 'DISABLED') {
        stateText = '‚è∏Ô∏è Disabled';
        stateColor = '#999';
      }

      stateEl.innerHTML = stateText;
      stateEl.style.color = stateColor;
    }

    // Current Moisture (use float for precision if available)
    // Check both undefined AND null (API returns null when data missing)
    const scMoisture = (sc.moisture_pct_float !== undefined && sc.moisture_pct_float !== null)
      ? sc.moisture_pct_float.toFixed(1)
      : (sc.moisture_pct !== undefined && sc.moisture_pct !== null ? sc.moisture_pct : '‚Äî');
    document.getElementById('status-current-moisture').textContent = scMoisture + '%';

    // Target Range
    if (preset && preset.start_pct && preset.stop_pct) {
      document.getElementById('status-target-range').textContent =
        `${preset.start_pct}-${preset.stop_pct}%`;
    }

    // Daily Water
    if (preset && preset.max_water_day_ml) {
      const dailyText = `${sc.daily_water_ml} / ${preset.max_water_day_ml} ml`;
      const dailyEl = document.getElementById('status-daily-water');
      dailyEl.textContent = dailyText;

      // Color code if approaching or exceeding limit
      if (sc.daily_hard_limit_reached) {
        dailyEl.style.color = '#b00';
        dailyEl.style.fontWeight = '600';
      } else if (sc.daily_water_ml > preset.max_water_day_ml * 0.8) {
        dailyEl.style.color = '#f57c00';
      } else {
        dailyEl.style.color = '#333';
        dailyEl.style.fontWeight = 'normal';
      }
    }

    // Watering Progress (show only during active watering cycle)
    const progressRow = document.getElementById('status-progress-row');
    if (sc.state === 'PULSE' || sc.state === 'SETTLE' || sc.state === 'CHECK') {
      progressRow.style.display = 'block';
      const progressText = `${sc.total_water_ml} / ${preset.max_water_cycle_ml || '?'} ml this cycle`;
      document.getElementById('status-watering-progress').textContent = progressText;
    } else {
      progressRow.style.display = 'none';
    }

    // Warning display
    const warningRow = document.getElementById('status-warning-row');
    const headerWarning = document.getElementById('header-warning');

    if (sc.warning_active && sc.warning_msg) {
      warningRow.style.display = 'block';
      document.getElementById('status-warning-message').textContent = sc.warning_msg;

      // Show warning in header
      headerWarning.style.display = 'flex';
      document.getElementById('warning-text').textContent = sc.warning_msg.substring(0, 40) + (sc.warning_msg.length > 40 ? '...' : '');
    } else {
      warningRow.style.display = 'none';
      headerWarning.style.display = 'none';
    }

    // Launch cancel section (show only during LAUNCH state)
    const armingSection = document.getElementById('arming-cancel-section');
    if (sc.state === 'LAUNCH') {
      armingSection.style.display = 'block';
      document.getElementById('arming-countdown-display').textContent = sc.arming_countdown;
    } else {
      armingSection.style.display = 'none';
    }

    // Update toggle state ONLY if we're actually in sensor mode
    // This prevents fighting between timer and sensor toggles
    const currentModeEl = document.querySelector('.mode-btn.selected');
    if (currentModeEl && currentModeEl.getAttribute('data-mode') === 'sensor') {
      const toggleEl = document.getElementById('sensor-auto-toggle');
      const toggleRowEl = document.getElementById('sensor-toggle-row');
      const shouldBeChecked = (sc.state !== 'DISABLED');

      // Don't update toggle while command is being processed (prevents bounce)
      if (!sensorCommandPending) {
        updatingSensorToggle = true;
        toggleEl.checked = shouldBeChecked;
        updatingSensorToggle = false;
      }

      // Now show the toggle row (was hidden to prevent OFF‚ÜíON flicker)
      if (toggleRowEl) toggleRowEl.style.visibility = 'visible';
    }

  } catch(e) {
    // Suppress noisy network errors
    if (!e.message?.includes('fetch')) {
      console.error('Sensor Controller status update failed:', e);
    }
  }
}

// Removed individual sensor controller interval - now handled by unified updateLoop

// Timer Controller Status (for Timer mode)
async function updateTimerControllerStatus() {
  try {
    const mode = document.querySelector('.mode-btn.selected')?.getAttribute('data-mode');

    // Hide timer details if not in timer mode
    const detailsSection = document.getElementById('timer-status-details');
    if (mode !== 'timer') {
      detailsSection.style.display = 'none';
      return;
    }

    // Fetch timer controller status
    const tc = await API.get('/timer/controller/status');

    // Save state globally for badge indication
    // Cloud mode: track LAUNCH start time for local countdown
    if (IS_CLOUD && tc.state === 'LAUNCH' && lastTimerState !== 'LAUNCH') {
      timerLaunchStartTime = Date.now();  // Just entered LAUNCH
    } else if (tc.state !== 'LAUNCH') {
      timerLaunchStartTime = null;  // Exited LAUNCH
    }
    lastTimerState = tc.state;

    // Fetch schedules count
    const schedules = await API.get('/schedules');

    // Show timer details section
    detailsSection.style.display = 'block';

    // Only update State field if we're actually in timer mode!
    if (mode === 'timer') {
      const stateEl = document.getElementById('current-state');
      let stateText = tc.state;
      let stateColor = '#333';

      if (tc.state === 'LAUNCH') {
        stateText = `‚è∞ LAUNCH ${tc.arming_countdown_sec}s`;
        stateColor = '#f57c00';
      } else if (tc.state === 'ACTIVE') {
        stateText = '‚è∞ Active';
        stateColor = '#2c5f2d';
      } else if (tc.state === 'WATERING') {
        stateText = 'üíß Watering';
        stateColor = '#1976d2';
      } else if (tc.state === 'DISABLED') {
        stateText = '‚úã Disabled';
        stateColor = '#666';
      }

      stateEl.textContent = stateText;
      stateEl.style.color = stateColor;
    }

    // Update timer details
    document.getElementById('status-next-watering').textContent = tc.next_watering_str || 'No schedules';
    document.getElementById('status-schedule-count').textContent = tc.schedule_exists ? `${schedules.count} active` : 'None';
    document.getElementById('timer-daily-water').textContent = tc.daily_water_ml + ' ml';

    // Watering duration (if currently watering)
    const wateringRow = document.getElementById('timer-watering-row');
    if (tc.state === 'WATERING' && tc.current_duration_sec > 0) {
      wateringRow.style.display = 'block';
      document.getElementById('timer-watering-duration').textContent = `${tc.current_duration_sec}s`;
    } else {
      wateringRow.style.display = 'none';
    }

    // Warning display
    const warningRow = document.getElementById('timer-warning-row');
    const headerWarning = document.getElementById('header-warning');

    if (tc.warning_active && tc.warning_msg) {
      warningRow.style.display = 'block';
      document.getElementById('timer-warning-message').textContent = tc.warning_msg;

      // Show warning in header (if sensor not already showing one)
      if (mode === 'timer') {
        headerWarning.style.display = 'flex';
        document.getElementById('warning-text').textContent = tc.warning_msg.substring(0, 40) + (tc.warning_msg.length > 40 ? '...' : '');
      }
    } else {
      warningRow.style.display = 'none';
      if (mode === 'timer') {
        headerWarning.style.display = 'none';
      }
    }

    // Launch cancel section (show only during LAUNCH state)
    const armingSection = document.getElementById('timer-arming-cancel-section');
    if (tc.state === 'LAUNCH') {
      armingSection.style.display = 'block';
      document.getElementById('timer-arming-countdown-display').textContent = tc.arming_countdown_sec;
    } else {
      armingSection.style.display = 'none';
    }

    // Update toggle state ONLY if we're actually in timer mode
    // This prevents fighting between timer and sensor toggles
    const currentModeEl = document.querySelector('.mode-btn.selected');
    if (currentModeEl && currentModeEl.getAttribute('data-mode') === 'timer') {
      const toggleEl = document.getElementById('timer-auto-toggle');
      const toggleRowEl = document.getElementById('timer-toggle-row');
      const shouldBeChecked = (tc.state !== 'DISABLED');

      // Set correct state BEFORE showing toggle (prevents visual flicker)
      updatingTimerToggle = true;
      toggleEl.checked = shouldBeChecked;
      updatingTimerToggle = false;

      // Now show the toggle row (was hidden to prevent OFF‚ÜíON flicker)
      if (toggleRowEl) toggleRowEl.style.visibility = 'visible';
    }

  } catch(e) {
    // Suppress noisy network errors
    if (!e.message?.includes('fetch')) {
      console.error('Timer Controller status update failed:', e);
    }
  }
}

// Cancel timer arming
async function cancelTimerArming() {
  try {
    await API.post('/timer/controller/cancel');
    updateControllerStatus(); // Use unified update instead
  } catch(e) {
    alert('Error canceling timer: ' + e.message);
  }
}

// Removed individual timer controller interval - now handled by unified updateLoop

// Unified controller status update loop - only update the active mode's controller
async function updateControllerStatus() {
  const mode = document.querySelector('.mode-btn.selected')?.getAttribute('data-mode');

  // Only update the controller for the current mode
  // This prevents toggle fighting and saves energy
  if (mode === 'sensor') {
    await updateSensorControllerStatus();
  } else if (mode === 'timer') {
    await updateTimerControllerStatus();
  }
  // If mode is 'off', neither controller needs updating
}

// Single update loop for controller status (saves energy, prevents conflicts)
setInterval(updateControllerStatus, 2000); // every 2 seconds
setTimeout(updateControllerStatus, 1000); // initial load after 1 sec

// Pump speed control
function speedPreview(val){document.getElementById('speed-display').textContent=val+'%';}
let speedDebounceTimer=null;
async function setSpeed(val){
  // Debounce to avoid multiple rapid calls on touch devices
  if(speedDebounceTimer) clearTimeout(speedDebounceTimer);
  speedDebounceTimer=setTimeout(async()=>{
    try{await API.post('/pump/speed?value='+val);}
    catch(e){alert('Speed set failed');}
  },300);
}
async function loadPumpSpeed(){
  try{
    const s=await API.get('/pump/status');
    const speed=s.speed!==undefined?s.speed:100;
    document.getElementById('speed-slider').value=speed;
    document.getElementById('speed-display').textContent=speed+'%';
  }catch(e){}
}
loadPumpSpeed(); // Load immediately (default 100% shown until data arrives)

// Plant card expand/collapse
let plantExpanded = false;
function togglePlantExpand() {
  const row = document.getElementById('plant-row');
  const details = document.getElementById('plant-details');
  plantExpanded = !plantExpanded;
  if (plantExpanded) {
    row.classList.add('expanded');
    details.classList.add('expanded');
  } else {
    row.classList.remove('expanded');
    details.classList.remove('expanded');
  }
}

// Load saved plant for this device
async function loadPlantCard() {
  if (!IS_CLOUD) return; // Only in cloud mode
  try {
    if (!DEVICE_ID) return;

    // Direct fetch - /plants/list is a global endpoint, not device-prefixed
    const url = `${API.cloudBase}/plants/list?device_id=${DEVICE_ID}`;
    const headers = API.getAuthHeaders();
    console.log('[Plant] Fetching:', url);
    const response = await fetch(url, { headers, cache: 'no-store' });
    console.log('[Plant] Response status:', response.status);
    if (!response.ok) throw new Error('Failed to load plants: ' + response.status);
    const resp = await response.json();
    console.log('[Plant] Data:', resp);
    const plants = resp.plants || [];

    // Get the most recent active plant
    const plant = plants.find(p => !p.deleted_at) || plants[0];
    if (!plant) return;

    // Show the card
    document.getElementById('plant-card').style.display = 'block';

    // Compact row data
    document.getElementById('plant-name').textContent = plant.scientific || '‚Äî';
    document.getElementById('plant-scientific').textContent = plant.common_name || '';
    document.getElementById('plant-range').textContent = `${plant.start_pct || 35}-${plant.stop_pct || 55}%`;

    // Frequency from preset
    const freq = {
      'succulent': 'Every 14-21 days',
      'drought_tolerant': 'Every 10-14 days',
      'standard': 'Every 7-10 days',
      'tropical': 'Every 5-7 days',
      'moisture_loving': 'Every 3-5 days'
    };
    const wateringText = freq[plant.preset] || 'Every 7-10 days';
    document.getElementById('plant-frequency').textContent = wateringText;
    document.getElementById('plant-watering-detail').textContent = wateringText;

    // Image if available (with fallback for PlantNet outages)
    if (plant.image_url) {
      const img = document.getElementById('plant-image');
      img.onerror = () => { img.style.display = 'none'; };
      img.src = plant.image_url;
      img.style.display = 'block';
    }

    // Expanded details: family, care level, indoor/outdoor
    let infoParts = [];
    if (plant.family) infoParts.push(plant.family);
    if (plant.care_level) infoParts.push(plant.care_level + ' care');
    // Only show Indoor if confirmed - Outdoor is misleading for tropical plants
    if (plant.indoor === true) infoParts.push('üè† Indoor');
    document.getElementById('plant-extra-info').textContent = infoParts.join(' ‚Ä¢ ');

    // Toxicity warning (with family fallback for old data)
    const warningEl = document.getElementById('plant-warning');
    let toxicHumans = plant.poisonous_to_humans === true;
    let toxicPets = plant.poisonous_to_pets === true;
    let toxicityNote = plant.toxicity_note || '';
    let toxicitySource = plant.toxicity_source || 'species';

    // Fallback: check family if no toxicity data from Perenual
    if (plant.poisonous_to_pets === undefined && plant.family) {
      const familyToxicity = TOXIC_FAMILIES[plant.family];
      if (familyToxicity) {
        toxicHumans = familyToxicity.humans;
        toxicPets = familyToxicity.pets;
        toxicityNote = familyToxicity.note;
        toxicitySource = 'family';
      }
    }

    if (toxicHumans || toxicPets) {
      // Show note as main message (less scary than "TOXIC")
      // Only show "Toxic to..." if no note available
      let label;
      if (toxicityNote) {
        label = `‚ö†Ô∏è ${toxicityNote}`;
        if (toxicPets) label += ' ‚Ä¢ Keep away from pets';
      } else {
        let warnings = [];
        if (toxicHumans) warnings.push('humans');
        if (toxicPets) warnings.push('pets');
        label = `‚ö†Ô∏è Toxic to ${warnings.join(' and ')}`;
      }
      warningEl.innerHTML = label;
      warningEl.style.display = 'block';
      warningEl.style.background = '#fff3e0';
      warningEl.style.color = '#e65100';
    } else if (plant.poisonous_to_pets === undefined && !TOXIC_FAMILIES[plant.family]) {
      // Unknown toxicity - show warning to research
      warningEl.textContent = `‚ö†Ô∏è Toxicity unknown ‚Äî research before keeping with pets`;
      warningEl.style.display = 'block';
      warningEl.style.background = '#fff3e0';
      warningEl.style.color = '#e65100';
    } else {
      warningEl.style.display = 'none';
    }

    // Description (if available from API)
    const descEl = document.getElementById('plant-description');
    if (plant.description) {
      descEl.textContent = plant.description;
      descEl.style.display = 'block';
    } else {
      descEl.style.display = 'none';
    }

    // Environment requirements
    if (plant.humidity_min || plant.humidity_max) {
      document.getElementById('plant-humidity').textContent = `${plant.humidity_min || 30}-${plant.humidity_max || 70}%`;
    }
    if (plant.temp_min || plant.temp_max) {
      document.getElementById('plant-temperature').textContent = `${plant.temp_min || 18}-${plant.temp_max || 24}¬∞C`;
    }

  } catch (e) {
    console.log('[Plant] Error loading plant:', e.message);
  }
}
// TODO: Enable when /plants/list endpoint is deployed to Lambda
// setTimeout(loadPlantCard, 500);
</script> </body></html>