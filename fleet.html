<!doctype html>
<html>
<head>
<script src="api-adapter.js"></script>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Polivalka Fleet</title>
<style>
  /* Reusing styles from local HTML (home.html) */
  body{font-family:system-ui,Arial;margin:0;padding:0;max-width:100%;background:#fafafa}
  .header{position:sticky;top:0;z-index:1000;background:#2c5f2d;color:#fff;padding:8px 10px;display:flex;justify-content:space-between;align-items:center;gap:8px}
  .header h1{margin:0;font-size:18px}
  .header-info{font-size:12px;text-align:right;line-height:1.3}
  .container{padding:18px;max-width:1200px;margin:0 auto}
  .card{border:1px solid #ddd;padding:16px;border-radius:12px;margin:12px 0;background:#fff}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .mono{font-family:ui-monospace,monospace}
  button{padding:8px 12px;border-radius:8px;border:1px solid #888;background:#fafafa;cursor:pointer}
  button.primary{background:#2c5f2d;color:#fff;border-color:#2c5f2d}
  button:hover{opacity:0.9}
  .muted{color:#666;font-size:14px}
  .danger{color:#b00;font-weight:600}
  .ok{color:#0a0}
  .warning{color:#f57c00;font-weight:600}

  /* Stats dashboard */
  .stats-row{display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:12px;margin-bottom:20px}
  .stat-card{background:#fff;border:1px solid #ddd;border-radius:12px;padding:16px;text-align:center}
  .stat-value{font-size:32px;font-weight:600;color:#2c5f2d}
  .stat-label{font-size:12px;color:#666;margin-top:4px}

  /* Filters */
  .filters{display:flex;gap:8px;margin-bottom:16px;flex-wrap:wrap}
  .filters input{padding:8px 12px;border:1px solid #ccc;border-radius:8px;flex:1;min-width:200px}
  .filters select{padding:8px 12px;border:1px solid #ccc;border-radius:8px}

  /* Device cards (grid mode) */
  .device-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(350px,1fr));gap:16px}

  /* Device list (expandable rows) */
  .device-list{display:flex;flex-direction:column;gap:2px}
  .device-list .device-card{border-left:3px solid transparent;padding:0;margin:0}
  .device-list .device-card.warning{border-left-color:#f57c00}
  .device-list .device-card.critical{border-left-color:#b00}

  /* Compact row (collapsed) */
  .device-row{display:flex;align-items:center;padding:12px 16px;cursor:pointer;transition:background 0.2s}
  .device-row:hover{background:#f9f9f9}
  .device-row.has-warnings{background:#fff9e6}
  .device-row .expand-icon{margin-right:12px;font-size:12px;color:#666;transition:transform 0.2s}
  .device-row.expanded .expand-icon{transform:rotate(90deg)}
  .device-row .warning-badge{color:#b00;font-size:16px;margin-right:8px;animation:pulse 2s infinite}
  .device-row .device-name{flex:1;font-weight:600;font-size:14px}
  .device-row .device-quick-info{display:flex;gap:12px;align-items:center;font-size:13px;flex-wrap:wrap}
  .last-watering-badge{font-size:11px;color:#666}
  .device-row .device-status{font-size:11px;padding:2px 6px;border-radius:6px;background:#e0e0e0;color:#666}
  .device-row .device-status.online{background:#e8f5e9;color:#2e7d32}
  .device-row .device-status.offline{background:#ffebee;color:#c62828}

  /* Expanded details (hidden by default) */
  .device-details{display:none;padding:0 16px 12px 40px;background:#fafafa}
  .device-details.expanded{display:block}
  .device-details .detail-row{display:flex;gap:16px;margin-bottom:8px;flex-wrap:wrap}
  .device-details .detail-item{font-size:13px;color:#666}
  .device-details .device-warnings{margin:8px 0;padding:8px;background:#fff3cd;border-radius:6px;font-size:12px}
  .device-details .device-actions{display:flex;gap:8px;margin-top:8px;flex-wrap:wrap}
  .device-details .device-actions button{font-size:12px;padding:6px 10px;flex:1;min-width:90px}
  .btn-primary{background:#2c5f2d;color:#fff;border-color:#2c5f2d}
  .btn-secondary{background:#f5f5f5;border-color:#ccc}
  .btn-danger{background:#b00;color:#fff;border-color:#900}

  /* View toggle */
  .view-toggle{display:flex;gap:4px;background:#f0f0f0;padding:4px;border-radius:8px;width:fit-content}
  .view-toggle button{background:transparent;border:none;padding:6px 12px;border-radius:6px;cursor:pointer;font-size:13px}
  .view-toggle button.active{background:#fff;box-shadow:0 1px 3px rgba(0,0,0,0.1)}
  .device-card{border:1px solid #ddd;border-radius:12px;padding:16px;background:#fff;position:relative}
  .device-card.offline{opacity:0.6;border-color:#ccc}
  .device-card.warning{border-left:4px solid #f57c00}
  .device-card.critical{border-left:4px solid #b00}
  .device-header{display:flex;justify-content:space-between;align-items:start;margin-bottom:12px}
  .device-name{font-size:18px;font-weight:600;color:#2c5f2d}
  .device-location{font-size:12px;color:#666;margin-top:2px}
  .device-status{font-size:11px;padding:3px 8px;border-radius:8px;background:#e0e0e0;color:#666}
  .device-status.online{background:#e8f5e9;color:#2e7d32}
  .device-status.offline{background:#ffebee;color:#c62828}
  .device-metrics{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin:12px 0}
  .metric{padding:8px;background:#f5f5f5;border-radius:8px}
  .metric-label{font-size:11px;color:#666}
  .metric-value{font-size:16px;font-weight:600;margin-top:2px}
  .metric-value.low{color:#b00}
  .metric-value.medium{color:#f57c00}
  .metric-value.good{color:#0a0}
  .device-warnings{margin:8px 0;padding:8px;background:#fff3cd;border-radius:8px;font-size:13px}
  .device-actions{display:flex;gap:8px;margin-top:12px}
  .device-actions button{flex:1;font-size:13px;padding:6px 10px}

  /* Mode badges */
  .mode-badge{display:inline-block;padding:4px 10px;border-radius:12px;font-size:11px;font-weight:600}
  .mode-manual{background:#fce4ec;color:#c2185b}
  .mode-timer{background:#e3f2fd;color:#1976d2}
  .mode-sensor{background:#fff3e0;color:#f57c00}

  /* Auth section (placeholder) */
  .auth-section{display:none}
  .auth-section.active{display:block}

  /* Admin controls */
  .admin-controls{background:#e8eaf6;border:2px solid #3f51b5;border-radius:12px;padding:16px;margin-bottom:20px}
  .admin-controls h3{margin:0 0 12px 0;color:#3f51b5}

  /* Animations */
  @keyframes pulse{
    0%,100%{opacity:1}
    50%{opacity:0.5}
  }

  /* Debug Console */
  .debug-console{position:fixed;bottom:0;left:0;right:0;height:250px;background:#1e1e1e;color:#d4d4d4;border-top:2px solid #007acc;font-family:ui-monospace,monospace;font-size:12px;display:flex;flex-direction:column;z-index:2000}
  .console-header{background:#2d2d2d;padding:8px 12px;display:flex;justify-content:space-between;align-items:center;border-bottom:1px solid #3e3e3e}
  .console-header h4{margin:0;font-size:13px;color:#fff}
  .console-body{flex:1;overflow-y:auto;padding:8px}
  .console-line{padding:2px 4px;border-bottom:1px solid #2d2d2d}
  .console-line.error{color:#f48771;background:#3f1a1a}
  .console-line.success{color:#89d185;background:#1a3f1a}
  .console-line.info{color:#75beff}
  .console-timestamp{color:#858585;margin-right:8px}
  .console-toggle{position:fixed;bottom:260px;right:20px;z-index:2001;background:#007acc;color:#fff;border:none;padding:8px 16px;border-radius:8px 8px 0 0;cursor:pointer;font-size:11px}
  .console-toggle.closed{bottom:0;border-radius:8px}

  /* Toggle button for Water Now */
  .btn-water-toggle{transition:all 0.3s;position:relative}
  .btn-water-toggle.active{background:#2c5f2d !important;color:#fff !important;border-color:#2c5f2d !important;box-shadow:inset 0 3px 5px rgba(0,0,0,0.3)}
  .water-hint{font-size:11px;color:#666;margin-left:4px;font-weight:normal}

  /* Automation Control Toggle */
  .automation-control{cursor:pointer;padding:4px 8px;border-radius:4px;transition:all 0.2s;display:inline-block;margin-left:8px;font-size:12px;font-weight:600}
  .automation-control:hover{background:rgba(0,170,0,0.1)}
  .automation-control span{user-select:none}
</style>
</head>
<body>

<!-- Auth Section (placeholder for future) -->
<div id="auth-section" class="auth-section active">
  <div style="text-align:center;padding:40px">
    <h2>üå± Polivalka Fleet Management</h2>
    <p class="muted">User authentication will be here</p>
    <button class="primary" onclick="mockLogin()">Continue as Admin (Mock)</button>
  </div>
</div>

<!-- Fleet View (hidden until auth) -->
<div id="fleet-view" style="display:none">

  <!-- Header -->
  <div class="header">
    <div>
      <h1>üå± Polivalka Fleet</h1>
      <div style="font-size:11px;opacity:0.8" id="user-info">Admin Dashboard</div>
    </div>
    <div class="header-info">
      <div id="header-time" class="mono" style="font-size:11px">Time: --:--</div>
      <div style="font-size:11px;cursor:pointer" onclick="logout()">üë§ <span id="username">Admin</span> | Logout</div>
    </div>
  </div>

  <div class="container">

    <!-- Stats Dashboard -->
    <div class="stats-row">
      <div class="stat-card">
        <div class="stat-value" id="stat-total">0</div>
        <div class="stat-label">Total Devices</div>
      </div>
      <div class="stat-card">
        <div class="stat-value ok" id="stat-online">0</div>
        <div class="stat-label">Online</div>
      </div>
      <div class="stat-card">
        <div class="stat-value warning" id="stat-warnings">0</div>
        <div class="stat-label">Warnings</div>
      </div>
      <div class="stat-card">
        <div class="stat-value" style="color:#1976d2" id="stat-watering">0</div>
        <div class="stat-label">Watering Now</div>
      </div>
    </div>

    <!-- Admin Controls (only for admin) -->
    <div id="admin-controls" class="admin-controls">
      <h3>üîß Admin Controls</h3>
      <div class="row">
        <button onclick="bulkAction('refresh')">üîÑ Refresh All</button>
        <button onclick="bulkAction('ota')">üì¶ Mass OTA Update</button>
        <button onclick="exportData()">üì• Export All Data</button>
      </div>
    </div>

    <!-- Filters -->
    <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px">
        <h3 style="margin:0">Device List</h3>
        <div class="view-toggle">
          <button id="view-cards" class="active" onclick="switchView('cards')">üî≤ Cards</button>
          <button id="view-list" onclick="switchView('list')">‚ò∞ List</button>
        </div>
      </div>
      <div class="filters">
        <input type="text" id="search-input" placeholder="üîç Search device name..." onkeyup="filterDevices()">
        <select id="location-filter" onchange="filterDevices()">
          <option value="">All Locations</option>
          <option value="Home">Home</option>
          <option value="Office">Office</option>
          <option value="Dacha">Dacha</option>
        </select>
        <select id="status-filter" onchange="filterDevices()">
          <option value="">All Status</option>
          <option value="online">Online</option>
          <option value="offline">Offline</option>
          <option value="warning">Warnings Only</option>
        </select>
        <select id="mode-filter" onchange="filterDevices()">
          <option value="">All Modes</option>
          <option value="manual">Manual</option>
          <option value="timer">Timer</option>
          <option value="sensor">Sensor</option>
        </select>
      </div>
    </div>

    <!-- Device Grid -->
    <div id="device-grid" class="device-grid">
      <!-- Populated by JS -->
    </div>

  </div>
</div>

<script>
// Mock data (will be replaced by Lambda API)
// –ò—Å–ø–æ–ª—å–∑—É–µ–º –†–ï–ê–õ–¨–ù–´–ï —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞: BB00C1 –∏ BC67E8
const MOCK_DEVICES = [
  {
    device_id: 'Polivalka-BB00C1',  // –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç
    name: 'Polivalka-BB00C1',  // Default name (–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –º–æ–∂–µ—Ç –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å)
    location: 'Home',
    room: 'Kitchen',
    moisture_pct: 45,
    battery_pct: null,  // AC power - –Ω–µ—Ç –±–∞—Ç–∞—Ä–µ–∏
    battery_charging: false,  // –ù–∞ —Ä–æ–∑–µ—Ç–∫–µ, –Ω–æ –Ω–µ –∑–∞—Ä—è–∂–∞–µ—Ç—Å—è (–Ω–µ—Ç –±–∞—Ç–∞—Ä–µ–∏)
    mode: 'sensor',
    state: 'STANDBY',
    firmware_version: 'v1.0.0',
    reboot_count: 5,
    last_watering: Date.now() - 2 * 3600 * 1000, // 2h ago
    last_update: Date.now() - 5 * 60 * 1000, // 5min ago
    warnings: []
  },
  {
    device_id: 'Polivalka-BC67E9',  // –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç
    name: 'Polivalka-BC67E9',  // Default name
    location: 'Home',
    room: 'Bedroom',
    moisture_pct: 18,
    battery_pct: 12,
    battery_charging: false,
    mode: 'sensor',
    state: 'STANDBY',
    firmware_version: 'v1.0.0',
    reboot_count: 3,
    last_watering: Date.now() - 24 * 3600 * 1000, // 1d ago
    last_update: Date.now() - 10 * 60 * 1000, // 10min ago
    warnings: ['Low battery (12%)', 'Moisture too low (18%)']  // Battery warning
  }
];

let currentUser = null;
let allDevices = [];
let currentView = 'list'; // 'cards' or 'list' (default: list for mobile-first)

// Pump settings (will be loaded from device status or use defaults)
let pumpCalibration = 2.5;  // ml/sec default
let maxWateringTime = 60;   // seconds default
let pumpRunningDevices = new Set();  // Track which devices have pump running
let pumpTimers = {};  // Track timers for each device

// Track expanded devices (to preserve state across re-renders)
let expandedDevices = new Set();

function mockLogin() {
  currentUser = {username: 'admin', role: 'admin'};
  document.getElementById('auth-section').style.display = 'none';
  document.getElementById('fleet-view').style.display = 'block';
  document.getElementById('username').textContent = currentUser.username;

  // Load devices
  loadDevices();

  // Update time
  updateTime();
  setInterval(updateTime, 60000);
}

function logout() {
  currentUser = null;
  document.getElementById('auth-section').style.display = 'block';
  document.getElementById('fleet-view').style.display = 'none';
}

async function loadDevices() {
  // Load devices from API
  try {
    allDevices = await API.get('/devices');
    console.log('‚úÖ API Response:', JSON.stringify(allDevices, null, 2));
  } catch (e) {
    console.error('‚ùå Failed to load devices:', e);
    allDevices = MOCK_DEVICES; // Fallback to mock data
    console.log('‚ö†Ô∏è Using MOCK_DEVICES:', JSON.stringify(MOCK_DEVICES, null, 2));
  }

  renderDevices(allDevices);
  updateStats(allDevices);
}

function renderDevices(devices) {
  const container = document.getElementById('device-grid');
  container.innerHTML = '';

  // Update container class based on view mode
  container.className = currentView === 'list' ? 'device-list' : 'device-grid';

  devices.forEach(device => {
    const card = createDeviceCard(device);
    container.appendChild(card);

    // Restore expanded state if device was expanded before
    if (expandedDevices.has(device.device_id)) {
      const rowElement = card.querySelector('.device-row');
      const detailsElement = card.querySelector(`#details-${device.device_id}`);
      if (rowElement && detailsElement) {
        rowElement.classList.add('expanded');
        detailsElement.classList.add('expanded');
      }
    }
  });
}

function createExpandableRow(device, isOnline, hasWarnings, isCritical) {
  const div = document.createElement('div');

  let cardClass = 'device-card';
  if (!isOnline) cardClass += ' offline';
  if (isCritical) cardClass += ' critical';
  else if (hasWarnings) cardClass += ' warning';

  div.className = cardClass;
  div.setAttribute('data-device-id', device.device_id);

  // Moisture & battery colors (–∫–∞–∫ –Ω–∞ home.html)
  let moistureColor = device.moisture_pct < 20 ? '#b00' : device.moisture_pct < 40 ? '#f57c00' : '#0a0';
  let batteryColor = device.battery_pct === null ? '#0a0' : device.battery_pct < 10 ? '#b00' : device.battery_pct < 30 ? '#f57c00' : '#0a0';

  // Charging icon (‚ö° –µ—Å–ª–∏ –Ω–∞ —Ä–æ–∑–µ—Ç–∫–µ, –∫–∞–∫ –Ω–∞ home.html)
  const chargingIcon = device.battery_charging ? ' ‚ö°' : '';

  // Battery display text (null = AC power, no battery)
  const batteryDisplay = device.battery_pct !== null ? `üîã${Math.round(device.battery_pct)}%${chargingIcon}` : '‚ö° AC';
  const batteryDisplayLong = device.battery_pct !== null ? `üîã Battery: ${Math.round(device.battery_pct)}%${chargingIcon}` : '‚ö° AC Power';

  // Time ago (handles both seconds and milliseconds)
  const lastWateringAgo = timeAgo(device.last_watering);

  // Last watering badge (–ø–æ–∫–∞–∑–∞—Ç—å –≤ –∫–æ—Ä–æ—Ç–∫–æ–π –≤–µ—Ä—Å–∏–∏ –µ—Å–ª–∏ –¥–∞–≤–Ω–æ)
  const lastWateringMs = device.last_watering && device.last_watering < 10000000000 ? device.last_watering * 1000 : device.last_watering;
  const hoursSinceWatering = lastWateringMs ? (Date.now() - lastWateringMs) / (3600 * 1000) : 999999;
  let lastWateringBadge = '';
  if (hoursSinceWatering > 24 && hoursSinceWatering < 999999) {
    lastWateringBadge = `<span class="last-watering-badge" style="color:#f57c00">üïê ${Math.floor(hoursSinceWatering / 24)}d ago</span>`;
  } else if (hoursSinceWatering > 12 && hoursSinceWatering < 999999) {
    lastWateringBadge = `<span class="last-watering-badge">üïê ${Math.floor(hoursSinceWatering)}h ago</span>`;
  }

  // Mode badge (—Å –∏–∫–æ–Ω–∫–∞–º–∏)
  const modeMap = {
    'manual': 'üîß Manual',
    'timer': '‚è∞ Timer',
    'sensor': 'üíß Sensor',
    'off': '‚úã Manual (legacy)'  // Should not happen (Lambda transforms off‚Üímanual), but graceful fallback
  };
  const modeName = modeMap[device.mode] || '‚ùì Unknown';
  const modeBadgeCompact = modeName ? `<span class="mode-badge mode-${device.mode}" style="font-size:11px;padding:2px 6px">${modeName}</span>` : '';

  // Automation control - use controller_enabled, not just mode!
  // mode = selected mode (sensor/timer/manual)
  // controller_enabled = automation actually running
  const controllerEnabled = device.controller_enabled === true;

  // Show automation status based on controller_enabled
  let automationText = '';
  let automationColor = '#666';

  if (controllerEnabled && device.mode === 'sensor') {
    automationText = '‚úÖ Auto ON (Sensor)';
    automationColor = '#0a0';
  } else if (controllerEnabled && device.mode === 'timer') {
    automationText = '‚úÖ Auto ON (Timer)';
    automationColor = '#0a0';
  } else {
    automationText = '‚≠ï Auto OFF';
    automationColor = '#999';
  }

  // Show automation status
  const automationControl = `
    <span class="automation-control" style="color: ${automationColor}; font-weight: 600">
      ${automationText}
    </span>
  `;

  div.innerHTML = `
    <!-- Compact row (click to expand) -->
    <div class="device-row ${hasWarnings ? 'has-warnings' : ''}" onclick="toggleDeviceExpand(this, '${device.device_id}')">
      <span class="expand-icon">‚ñ∂</span>
      ${hasWarnings ? '<span class="warning-badge">‚ö†Ô∏è</span>' : ''}
      <span class="device-name">üå± ${device.name}</span>
      <div class="device-quick-info">
        <span style="color:${moistureColor}">üíß${device.moisture_pct}%</span>
        <span style="color:${batteryColor}">${batteryDisplay}</span>
        ${modeBadgeCompact}
        ${automationControl}
        ${lastWateringBadge}
        <span class="device-status ${isOnline ? 'online' : 'offline'}">${isOnline ? '‚óè Online' : '‚óã Offline'}</span>
      </div>
    </div>

    <!-- Expanded details (hidden by default) -->
    <div class="device-details" id="details-${device.device_id}">
      <div class="detail-row">
        <span class="detail-item">Mode: ${modeName}</span>
        <span class="detail-item">Water: ‚âà${(maxWateringTime * pumpCalibration).toFixed(0)}ml / ${maxWateringTime}s</span>
        <span class="detail-item">üìç ${device.location} / ${device.room}</span>
      </div>

      <div class="detail-row" style="margin-top:8px">
        <span class="detail-item" style="color:${moistureColor}">üíß Moisture: ${device.moisture_pct}% (ADC: ${device.adc_raw || 'N/A'})</span>
        <span class="detail-item" style="color:${batteryColor}">${batteryDisplayLong}</span>
        <span class="detail-item">Last watering: ${lastWateringAgo}</span>
      </div>

      <div class="detail-row" style="margin-top:8px">
        <span class="detail-item">üîß Firmware: ${device.firmware_version || 'v1.0.0'}</span>
        <span class="detail-item">üîÑ Reboots: ${device.reboot_count || 'N/A'}</span>
        <span class="detail-item">‚è± Uptime: ${device.uptime || 'N/A'}</span>
      </div>

      ${hasWarnings ? `
        <div class="device-warnings">
          ‚ö†Ô∏è ${device.warnings.join('<br>‚ö†Ô∏è ')}
        </div>
      ` : ''}

      <div class="device-actions">
        <button onclick="event.stopPropagation(); refreshSensor('${device.device_id}')" class="btn-secondary">üîÑ Refresh</button>
        <button onclick="event.stopPropagation(); startPump('${device.device_id}', event)" class="btn-primary btn-water-toggle">üíß Water Now</button>
        <button onclick="event.stopPropagation(); stopPump('${device.device_id}', event)" class="btn-danger">‚õî Stop</button>
        <button onclick="event.stopPropagation(); viewDevice('${device.device_id}')">üè† Home</button>
        <button onclick="event.stopPropagation(); deviceUpdate('${device.device_id}')">üì¶ OTA Update</button>
        <button onclick="event.stopPropagation(); viewLogs('${device.device_id}')">üìù Logs</button>
      </div>
    </div>
  `;

  return div;
}

function toggleDeviceExpand(rowElement, deviceId) {
  const detailsElement = document.getElementById('details-' + deviceId);
  const isExpanded = detailsElement.classList.contains('expanded');

  if (isExpanded) {
    // Collapse
    detailsElement.classList.remove('expanded');
    rowElement.classList.remove('expanded');
    expandedDevices.delete(deviceId);
  } else {
    // Expand
    detailsElement.classList.add('expanded');
    rowElement.classList.add('expanded');
    expandedDevices.add(deviceId);

    // Auto-refresh sensor data when expanding (to show fresh data in Home)
    refreshSensorSilent(deviceId);
  }
}

function switchView(view) {
  currentView = view;

  // Update button states
  document.getElementById('view-cards').classList.toggle('active', view === 'cards');
  document.getElementById('view-list').classList.toggle('active', view === 'list');

  // Re-render devices
  renderDevices(allDevices.filter(device => {
    // Re-apply current filters
    const search = document.getElementById('search-input').value.toLowerCase();
    const location = document.getElementById('location-filter').value;
    const status = document.getElementById('status-filter').value;
    const mode = document.getElementById('mode-filter').value;

    if (search && !device.name.toLowerCase().includes(search)) return false;
    if (location && device.location !== location) return false;

    const lastUpdateMs = device.last_update < 10000000000 ? device.last_update * 1000 : device.last_update;
    const isOnline = (Date.now() - lastUpdateMs) < 2 * 60 * 60 * 1000;
    const hasWarnings = device.warnings.length > 0 || (device.battery_pct !== null && device.battery_pct < 10) || device.moisture_pct < 15;
    if (status === 'online' && !isOnline) return false;
    if (status === 'offline' && isOnline) return false;
    if (status === 'warning' && !hasWarnings) return false;
    if (mode && device.mode !== mode) return false;

    return true;
  }));
}

function createDeviceCard(device) {
  const div = document.createElement('div');

  // Use device.online from API (Lambda already calculated with 10 min threshold for testing mode)
  // Fallback to local calculation if device.online is missing (shouldn't happen)
  const isOnline = device.online !== undefined ? device.online :
                   ((Date.now() - (device.last_update < 10000000000 ? device.last_update * 1000 : device.last_update)) < 10 * 60 * 1000);
  const hasWarnings = device.warnings.length > 0;
  const isCritical = (device.battery_pct !== null && device.battery_pct < 10) || device.moisture_pct < 15;

  let cardClass = 'device-card';
  if (!isOnline) cardClass += ' offline';
  if (isCritical) cardClass += ' critical';
  else if (hasWarnings) cardClass += ' warning';

  div.className = cardClass;
  div.setAttribute('data-device-id', device.device_id);

  // List mode: expandable row
  if (currentView === 'list') {
    return createExpandableRow(device, isOnline, hasWarnings, isCritical);
  }

  // Cards mode: full card (original)

  // Moisture color
  let moistureClass = 'good';
  if (device.moisture_pct < 20) moistureClass = 'low';
  else if (device.moisture_pct < 40) moistureClass = 'medium';

  // Battery color (safe null check)
  let batteryClass = 'good';
  if (device.battery_pct !== null) {
    if (device.battery_pct < 10) batteryClass = 'low';
    else if (device.battery_pct < 30) batteryClass = 'medium';
  }

  // Mode badge (List view - —Å –∏–∫–æ–Ω–∫–∞–º–∏, —Å–∫—Ä—ã–≤–∞–µ–º 'off')
  const modeMapList = {
    'manual': 'üîß Manual',
    'timer': '‚è∞ Timer',
    'sensor': 'üíß Sensor',
    'off': ''
  };
  const modeNameList = modeMapList[device.mode] || '';
  const modeBadge = modeNameList ? `<span class="mode-badge mode-${device.mode}">${modeNameList}</span>` : '';

  // Watering status
  const isWatering = device.state === 'PULSE' || device.state === 'WATERING';
  const wateringBadge = isWatering ? '<span style="color:#1976d2;font-weight:600">üíß Watering...</span>' : '';

  // Battery display (null = AC power, no battery)
  const chargingIcon = device.battery_charging ? ' ‚ö°' : '';
  const batteryMetric = device.battery_pct !== null ? `${Math.round(device.battery_pct)}%${chargingIcon}` : '‚ö° AC Power';

  // Time ago
  const lastWateringAgo = timeAgo(device.last_watering);
  const lastUpdateAgo = timeAgo(device.last_update);

  div.innerHTML = `
    <div class="device-header">
      <div>
        <div class="device-name">üå± ${device.name}</div>
        <div class="device-location">üìç ${device.location} / ${device.room}</div>
      </div>
      <div class="device-status ${isOnline ? 'online' : 'offline'}">${isOnline ? '‚óè Online' : '‚óã Offline'}</div>
    </div>

    <div style="margin:8px 0">
      ${modeBadge} ${wateringBadge}
    </div>

    <div class="device-metrics">
      <div class="metric">
        <div class="metric-label">üíß Moisture</div>
        <div class="metric-value ${moistureClass}">${device.moisture_pct}%</div>
      </div>
      <div class="metric">
        <div class="metric-label">üîã Battery</div>
        <div class="metric-value ${batteryClass}">${batteryMetric}</div>
      </div>
    </div>

    <div class="muted" style="font-size:12px;margin:8px 0">
      Last watering: ${lastWateringAgo}<br>
      Last update: ${lastUpdateAgo}
    </div>

    ${hasWarnings ? `
      <div class="device-warnings">
        ‚ö†Ô∏è ${device.warnings.join('<br>‚ö†Ô∏è ')}
      </div>
    ` : ''}

    <div class="device-actions">
      <button onclick="refreshSensor('${device.device_id}')" class="btn-primary">üîÑ Refresh</button>
      <button onclick="startPump('${device.device_id}', event)" class="btn-primary btn-water-toggle">üíß Water Now</button>
      <button onclick="stopPump('${device.device_id}', event)" class="btn-danger">‚õî Stop</button>
      <button onclick="viewDevice('${device.device_id}')">üè† Home</button>
      <button onclick="deviceUpdate('${device.device_id}')">üì¶ OTA Update</button>
      <button onclick="viewLogs('${device.device_id}')">üìù Logs</button>
    </div>
  `;

  return div;
}

function updateStats(devices) {
  const total = devices.length;
  const online = devices.filter(d => {
    const lastUpdateMs = d.last_update < 10000000000 ? d.last_update * 1000 : d.last_update;
    return (Date.now() - lastUpdateMs) < 2 * 60 * 60 * 1000;
  }).length;
  const warnings = devices.filter(d => d.warnings.length > 0 || (d.battery_pct !== null && d.battery_pct < 10) || d.moisture_pct < 15).length;
  const watering = devices.filter(d => d.state === 'PULSE' || d.state === 'WATERING').length;

  document.getElementById('stat-total').textContent = total;
  document.getElementById('stat-online').textContent = online;
  document.getElementById('stat-warnings').textContent = warnings;
  document.getElementById('stat-watering').textContent = watering;
}

function filterDevices() {
  const search = document.getElementById('search-input').value.toLowerCase();
  const location = document.getElementById('location-filter').value;
  const status = document.getElementById('status-filter').value;
  const mode = document.getElementById('mode-filter').value;

  const filtered = allDevices.filter(device => {
    // Search filter
    if (search && !device.name.toLowerCase().includes(search)) return false;

    // Location filter
    if (location && device.location !== location) return false;

    // Status filter
    const lastUpdateMs = device.last_update < 10000000000 ? device.last_update * 1000 : device.last_update;
    const isOnline = (Date.now() - lastUpdateMs) < 2 * 60 * 60 * 1000;
    const hasWarnings = device.warnings.length > 0 || (device.battery_pct !== null && device.battery_pct < 10) || device.moisture_pct < 15;
    if (status === 'online' && !isOnline) return false;
    if (status === 'offline' && isOnline) return false;
    if (status === 'warning' && !hasWarnings) return false;

    // Mode filter
    if (mode && device.mode !== mode) return false;

    return true;
  });

  renderDevices(filtered);
}

function timeAgo(timestamp) {
  if (!timestamp) return 'never';

  // Lambda returns seconds, convert to milliseconds
  const timestampMs = timestamp < 10000000000 ? timestamp * 1000 : timestamp;

  const seconds = Math.floor((Date.now() - timestampMs) / 1000);
  if (seconds < 0) return 'just now';
  if (seconds < 60) return `${seconds}s ago`;
  const minutes = Math.floor(seconds / 60);
  if (minutes < 60) return `${minutes}m ago`;
  const hours = Math.floor(minutes / 60);
  if (hours < 24) return `${hours}h ago`;
  const days = Math.floor(hours / 24);
  return `${days}d ago`;
}

function updateTime() {
  const now = new Date();
  const timeStr = now.toTimeString().substring(0, 5);
  document.getElementById('header-time').textContent = 'Time: ' + timeStr;
}

function showToast(message, type = 'info') {
  // Create toast element
  const toast = document.createElement('div');
  toast.className = `toast toast-${type}`;
  toast.textContent = message;

  // Style the toast
  Object.assign(toast.style, {
    position: 'fixed',
    top: '20px',
    right: '20px',
    padding: '12px 20px',
    borderRadius: '8px',
    backgroundColor: type === 'error' ? '#dc3545' : '#28a745',
    color: 'white',
    fontSize: '14px',
    fontWeight: '500',
    boxShadow: '0 4px 12px rgba(0,0,0,0.3)',
    zIndex: 10000,
    opacity: 0,
    transition: 'opacity 0.3s ease',
    maxWidth: '400px'
  });

  // Add to page
  document.body.appendChild(toast);

  // Fade in
  setTimeout(() => toast.style.opacity = 1, 10);

  // Remove after 4 seconds
  setTimeout(() => {
    toast.style.opacity = 0;
    setTimeout(() => toast.remove(), 300);
  }, 4000);
}

// Device actions
// Device control commands (send MQTT via Lambda)

async function readSensor(deviceId) {
  try {
    // Use api-adapter.js instead of hardcoded URL
    const result = await API.post(`/device/${deviceId}/command`, {
      command: 'get_sensor',
      params: {}
    });

    alert(`‚úì Sensor reading requested for ${deviceId}\nCommand ID: ${result.command_id}`);

    // Refresh device data after 2 seconds
    setTimeout(() => loadDevices(), 2000);
  } catch(e) {
    alert(`Error: ${e.message}`);
  }
}

async function refreshSensor(deviceId) {
  try {
    // Call real-time status endpoint (returns sensor + mode + battery + pump)
    const result = await API.get(`/device/${deviceId}/sensor`);

    // Update device in allDevices array
    const device = allDevices.find(d => d.device_id === deviceId);
    if (device) {
      device.moisture_pct = result.moisture_pct;
      device.adc_raw = result.adc_raw;
      device.mode = result.mode;  // Update mode (manual/timer/sensor)
      device.battery = result.battery;  // Update battery data
      device.last_update = result.timestamp;
      device.online = true;  // Device responded ‚Üí Online

      // Re-render devices
      renderDevices(allDevices);
      updateStats(allDevices);

      // Show success feedback with updated values
      showToast(`‚úÖ Refreshed: ${result.moisture_pct}% | Mode: ${result.mode}`, 'success');
    }

  } catch(e) {
    // Device didn't respond ‚Üí Offline
    const device = allDevices.find(d => d.device_id === deviceId);
    if (device) {
      device.online = false;
      renderDevices(allDevices);
      updateStats(allDevices);
    }

    // Show error toast (non-blocking)
    showToast(e.message.includes('408') ?
      '‚ö†Ô∏è Device offline or sleeping. Try again later.' :
      `‚ùå Error: ${e.message}`, 'error');
  }
}

// Silent version for auto-refresh when expanding Home (no UI feedback)
async function refreshSensorSilent(deviceId) {
  try {
    // Call real-time status endpoint (returns sensor + mode + battery + pump)
    const result = await API.get(`/device/${deviceId}/sensor`);

    // Update device in allDevices array
    const device = allDevices.find(d => d.device_id === deviceId);
    if (device) {
      device.moisture_pct = result.moisture_pct;
      device.adc_raw = result.adc_raw;
      device.mode = result.mode;  // Update mode (manual/timer/sensor)
      device.battery = result.battery;  // Update battery data
      device.last_update = result.timestamp;
      device.online = true;  // Device responded ‚Üí Online

      // Re-render devices (will preserve expanded state)
      renderDevices(allDevices);
      updateStats(allDevices);
    }

    // Silent success - no toasts, no button updates

  } catch(e) {
    // Device didn't respond ‚Üí Offline
    const device = allDevices.find(d => d.device_id === deviceId);
    if (device) {
      device.online = false;
      renderDevices(allDevices);
      updateStats(allDevices);
    }

    // Only show error toast if request fails
    showToast(e.message.includes('408') ?
      '‚ö†Ô∏è Device offline or sleeping.' :
      `‚ùå Error refreshing: ${e.message}`, 'error');
  }
}

async function startPump(deviceId, event) {
  if (event) event.stopPropagation();

  // Prevent multiple clicks - check if pump already running
  if (pumpRunningDevices.has(deviceId)) {
    return; // Ignore click if pump already running
  }

  // Mark as running BEFORE API call to prevent race condition
  pumpRunningDevices.add(deviceId);
  updatePumpButton(deviceId, true, 0, maxWateringTime);

  try {
    // Start pump for maxWateringTime
    await API.post(`/device/${deviceId}/pump?sec=${maxWateringTime}`);

    // Start timer to update elapsed time
    startPumpTimer(deviceId);

    // Silent success - device card will update automatically
    setTimeout(() => loadDevices(), 2000);
  } catch(e) {
    // On error, revert state
    pumpRunningDevices.delete(deviceId);
    stopPumpTimer(deviceId);
    updatePumpButton(deviceId, false);
    showToast(`‚ùå Failed to start pump: ${e.message}`, 'error');
  }
}

async function stopPump(deviceId, event) {
  if (event) event.stopPropagation();

  // Prevent multiple clicks - check if pump is NOT running
  if (!pumpRunningDevices.has(deviceId)) {
    return; // Ignore click if pump not running
  }

  // Remove from set BEFORE API call to prevent race condition
  pumpRunningDevices.delete(deviceId);
  stopPumpTimer(deviceId);
  updatePumpButton(deviceId, false);

  try {
    // Stop pump immediately (no confirmation for safety - quick action)
    await API.post(`/device/${deviceId}/pump/stop`);

    // Silent success - device card will update automatically
    setTimeout(() => loadDevices(), 1000);
  } catch(e) {
    // On error, revert state (mark as running again)
    pumpRunningDevices.add(deviceId);
    // startPumpTimer will call updatePumpButton internally
    startPumpTimer(deviceId);
    showToast(`‚ùå Failed to stop pump: ${e.message}`, 'error');
  }
}

async function toggleAutomation(deviceId, enable) {
  // Toggle automation (controller enabled/disabled)
  try {
    // Show loading state
    const toggles = document.querySelectorAll(`[data-device-id="${deviceId}"] .automation-control`);
    toggles.forEach(toggle => {
      toggle.style.opacity = '0.5';
      toggle.style.pointerEvents = 'none';
    });

    // Determine the mode to set
    let newMode;
    if (enable) {
      // Enable automation - use the last known automated mode or default to sensor
      const device = allDevices.find(d => d.device_id === deviceId);
      if (device && device.last_auto_mode) {
        newMode = device.last_auto_mode; // timer or sensor
      } else {
        newMode = 'sensor'; // Default to sensor mode
      }
    } else {
      // Disable automation - switch to manual mode
      newMode = 'manual';
    }

    // Send mode change command
    const result = await API.post(`/device/${deviceId}/mode`, { mode: newMode });

    if (result.success) {
      showToast(`Automation ${enable ? 'enabled' : 'disabled'} (${newMode} mode)`, 'success');

      // Wait a bit for the device to process the command
      setTimeout(async () => {
        // Reload devices from API to get fresh data
        await loadDevices();
      }, 2000);
    } else {
      showToast(`Failed to ${enable ? 'enable' : 'disable'} automation`, 'error');
    }
  } catch (error) {
    console.error('Toggle automation error:', error);
    showToast(`Failed to ${enable ? 'enable' : 'disable'} automation: ${error.message}`, 'error');
  } finally {
    // Restore toggle state
    const toggles = document.querySelectorAll(`[data-device-id="${deviceId}"] .automation-control`);
    toggles.forEach(toggle => {
      toggle.style.opacity = '1';
      toggle.style.pointerEvents = 'auto';
    });
  }
}

function updatePumpButton(deviceId, isRunning, elapsed = 0, total = maxWateringTime) {
  // Find and update Water Now button state for this device
  const buttons = document.querySelectorAll(`[data-device-id="${deviceId}"] .btn-water-toggle`);
  buttons.forEach(btn => {
    if (isRunning) {
      btn.classList.add('active');
      const remaining = total - elapsed;
      btn.textContent = `üõë Stop (${elapsed}s / ${total}s)`;
      btn.onclick = (e) => stopPump(deviceId, e);
    } else {
      btn.classList.remove('active');
      btn.textContent = `üíß Water Now`;
      btn.onclick = (e) => startPump(deviceId, e);
    }
  });
}

function startPumpTimer(deviceId) {
  // Clear existing timer if any (prevent memory leak)
  if (pumpTimers[deviceId]) {
    clearInterval(pumpTimers[deviceId]);
  }

  let elapsed = 0;
  pumpTimers[deviceId] = setInterval(() => {
    elapsed++;
    updatePumpButton(deviceId, true, elapsed, maxWateringTime);

    // Auto-stop timer when reaching max time
    if (elapsed >= maxWateringTime) {
      stopPumpTimer(deviceId);
      pumpRunningDevices.delete(deviceId);
      updatePumpButton(deviceId, false);
    }
  }, 1000);
}

function stopPumpTimer(deviceId) {
  if (pumpTimers[deviceId]) {
    clearInterval(pumpTimers[deviceId]);
    delete pumpTimers[deviceId];
  }
}

function viewDevice(deviceId) {
  // Navigate to home.html with device_id parameter
  window.location.href = `home.html?device=${deviceId}`;
}

function deviceUpdate(deviceId) {
  window.location.href = `ota.html?device=${deviceId}`;
}

// Admin actions
async function bulkAction(action) {
  if (action === 'refresh') {
    // Show non-blocking toast instead of confirm dialog
    showToast(`üîÑ Refreshing ${allDevices.length} devices...`, 'info');

    // PARALLEL requests to all devices (not sequential!)
    // Max time = 10 seconds (longest timeout), NOT 10 * device_count
    const promises = allDevices.map(async device => {
      try {
        // Real-time status check (returns sensor + mode + battery + pump)
        const result = await API.get(`/device/${device.device_id}/sensor`);

        // Update device data
        device.moisture_pct = result.moisture_pct;
        device.adc_raw = result.adc_raw;
        device.mode = result.mode;  // Update mode (manual/timer/sensor)
        device.battery = result.battery;  // Update battery data
        device.last_update = result.timestamp;
        device.online = true;  // Device responded ‚Üí Online

        return {device_id: device.device_id, success: true};
      } catch(e) {
        // 408 timeout or error ‚Üí Device offline
        device.online = false;
        return {device_id: device.device_id, success: false, error: e.message};
      }
    });

    // Wait for all requests (parallel, max 10 sec total)
    const results = await Promise.all(promises);

    // Re-render with updated online/offline status
    renderDevices(allDevices);
    updateStats(allDevices);

    // Show non-blocking toast instead of alert
    const successful = results.filter(r => r.success).length;
    const failed = results.filter(r => !r.success).length;
    showToast(`‚úÖ Refresh complete! ${successful} online, ${failed} offline`, failed > 0 ? 'warning' : 'success');

  } else if (action === 'ota') {
    massOTAUpdate();
  } else {
    alert(`Bulk action: ${action} (TODO: implement)`);
  }
}

// Mass OTA Update
async function massOTAUpdate() {
  // Step 1: Select firmware file
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.bin';

  input.onchange = async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    // Confirm
    const onlineDevices = allDevices.filter(d => d.online);
    if (onlineDevices.length === 0) {
      alert('‚ùå No online devices to update!');
      return;
    }

    if (!confirm(`üì¶ Mass OTA Update\n\nFile: ${file.name} (${(file.size/1024/1024).toFixed(2)} MB)\nOnline devices: ${onlineDevices.length}\n\n‚ö†Ô∏è This will update ALL online devices!\n\nContinue?`)) {
      return;
    }

    // Step 2: Upload firmware to S3 (use first device for presigned URL)
    showToast('üì§ Uploading firmware to S3...', 'info');

    try {
      // Get presigned URL from first device (same S3 bucket for all devices)
      const urlResponse = await API.get(`/device/${onlineDevices[0].device_id}/ota/upload-url`);

      if (!urlResponse.upload_url) {
        throw new Error('Failed to get S3 upload URL');
      }

      // Upload to S3
      const uploadResponse = await fetch(urlResponse.upload_url, {
        method: 'PUT',
        body: file,
        headers: {'Content-Type': 'application/octet-stream'}
      });

      if (!uploadResponse.ok) {
        throw new Error(`S3 upload failed: ${uploadResponse.status}`);
      }

      const firmwareUrl = urlResponse.download_url;
      showToast('‚úÖ Firmware uploaded to S3', 'success');

      // Step 3: Trigger OTA for all online devices
      const results = [];
      let completed = 0;

      for (const device of onlineDevices) {
        try {
          showToast(`Updating ${device.device_id}... (${completed+1}/${onlineDevices.length})`, 'info');

          await API.post(`/device/${device.device_id}/ota`, {
            url: firmwareUrl,
            version: 'cloud-update'
          });

          results.push({device_id: device.device_id, success: true});
        } catch(e) {
          results.push({device_id: device.device_id, success: false, error: e.message});
        }
        completed++;
      }

      // Step 4: Show results
      const successful = results.filter(r => r.success).length;
      const failed = results.filter(r => !r.success).length;

      let resultMsg = `‚úÖ Mass OTA Update Complete!\n\nSuccessful: ${successful}\nFailed: ${failed}\n\n`;

      if (failed > 0) {
        resultMsg += 'Failed devices:\n';
        results.filter(r => !r.success).forEach(r => {
          resultMsg += `- ${r.device_id}: ${r.error}\n`;
        });
      }

      alert(resultMsg);

      showToast('‚úÖ Mass OTA completed. Devices will restart in ~60 seconds.', 'success');

    } catch(e) {
      console.error('Mass OTA failed:', e);
      showToast(`‚ùå Mass OTA failed: ${e.message}`, 'error');
    }
  };

  input.click();
}

function exportData() {
  console.log('Export data');
  alert('Export all data (TODO: implement)');
}

async function viewLogs(deviceId) {
  // Store device ID globally for tab switching
  currentLogsDeviceId = deviceId;

  // Show modal
  document.getElementById('logsModal').style.display = 'flex';
  document.getElementById('logsModalTitle').textContent = `üìù Logs - ${deviceId}`;

  // Load Activity logs by default (highlight Activity tab)
  await switchLogsTab('activity');
}

function closeLogsModal() {
  document.getElementById('logsModal').style.display = 'none';
}

// Global variable to store current device ID for logs modal
let currentLogsDeviceId = null;

// Switch between Activity and Device logs tabs
async function switchLogsTab(tab) {
  if (!currentLogsDeviceId) return;

  // Update tab button styles
  const activityBtn = document.getElementById('logsTabActivity');
  const deviceBtn = document.getElementById('logsTabDevice');

  if (tab === 'activity') {
    activityBtn.style.background = '#4CAF50';
    activityBtn.style.color = 'white';
    deviceBtn.style.background = '';
    deviceBtn.style.color = '';
    await viewActivityLogs(currentLogsDeviceId);
  } else if (tab === 'device') {
    deviceBtn.style.background = '#2196F3';
    deviceBtn.style.color = 'white';
    activityBtn.style.background = '';
    activityBtn.style.color = '';
    await viewDeviceLogs(currentLogsDeviceId);
  }
}

// View Activity logs (DynamoDB - 7 days)
async function viewActivityLogs(deviceId) {
  try {
    document.getElementById('logsContent').textContent = 'Loading Activity logs...';

    const data = await API.get(`/device/${deviceId}/activity`);

    const logLines = data.activity.map(item => {
      const date = new Date(item.timestamp * 1000);
      const dateStr = date.toLocaleDateString('en-CA');
      const timeStr = date.toLocaleTimeString('en-US', {hour12: false});
      const datetime = `${dateStr} ${timeStr}`;
      const level = item.level || 'INFO';
      const component = item.component || 'UNKNOWN';

      if (item.type === 'COMMAND') {
        const statusIcon = item.status === 'success' ? '‚úÖ' : item.status === 'error' ? '‚ùå' : '‚è≥';
        const msg = item.message || `Command: ${item.command}`;
        return `${level.charAt(0)} (${datetime}) ${component}: ${item.command} ‚Üí ${statusIcon} ${msg}`;
      } else if (item.type === 'OTA') {
        // OTA Update event
        return `I (${datetime}) ${component}: ${item.message}`;
      } else if (item.type === 'REBOOT') {
        // Reboot event (crash, power loss, manual restart)
        return `${level.charAt(0)} (${datetime}) ${component}: ${item.message}`;
      } else if (item.type === 'SYSTEM') {
        return `${level.charAt(0)} (${datetime}) ${component}: ${item.message}`;
      } else {
        // SENSOR, BATTERY, PUMP - –≤—Å–µ –∏–º–µ—é—Ç item.message
        return `${level.charAt(0)} (${datetime}) ${component}: ${item.message}`;
      }
    }).join('\n');

    document.getElementById('logsContent').textContent = logLines || 'No activity logs available (last 7 days)';

  } catch(e) {
    document.getElementById('logsContent').textContent = `Error loading Activity logs: ${e.message}`;
  }
}

// View Device RAM logs (ESP32 circular buffer - 100 events)
async function viewDeviceLogs(deviceId) {
  try {
    document.getElementById('logsContent').textContent = 'Loading Device RAM logs...';

    const data = await API.get(`/device/${deviceId}/logs`);

    // Format logs with uptime
    const uptimeSec = (data.uptime_ms / 1000).toFixed(2);
    const header = `Device Uptime: ${uptimeSec}s | RAM Buffer: ${data.count} events\n${'='.repeat(80)}\n`;

    const logLines = data.logs.map(log => {
      return log.formatted; // Already formatted by Lambda as "[  123.456] EVENT_TEXT"
    }).join('\n');

    document.getElementById('logsContent').textContent = header + (logLines || 'No device logs available');

  } catch(e) {
    if (e.message.includes('408')) {
      document.getElementById('logsContent').textContent = '‚ö†Ô∏è Device is offline or sleeping.\n\nDevice RAM logs are only available when device is online and awake.';
    } else {
      document.getElementById('logsContent').textContent = `Error loading Device logs: ${e.message}`;
    }
  }
}

// ========== DEBUG CONSOLE ==========
const consoleLines = [];
const MAX_CONSOLE_LINES = 100;

function logToConsole(message, type = 'info') {
  const timestamp = new Date().toISOString().substr(11, 8);
  const line = { timestamp, message, type };
  consoleLines.push(line);

  if (consoleLines.length > MAX_CONSOLE_LINES) {
    consoleLines.shift();
  }

  renderConsole();
}

function renderConsole() {
  const consoleBody = document.getElementById('consoleBody');
  if (!consoleBody) return;

  consoleBody.innerHTML = consoleLines.map(line =>
    `<div class="console-line ${line.type}">
      <span class="console-timestamp">${line.timestamp}</span>
      <span>${line.message}</span>
    </div>`
  ).join('');

  // Auto-scroll to bottom
  consoleBody.scrollTop = consoleBody.scrollHeight;
}

function toggleConsole() {
  const console = document.getElementById('debugConsole');
  const toggle = document.getElementById('consoleToggle');

  if (console.style.display === 'none') {
    console.style.display = 'flex';
    toggle.textContent = '‚ñº Hide Console';
    toggle.classList.remove('closed');
  } else {
    console.style.display = 'none';
    toggle.textContent = '‚ñ≤ Show Console';
    toggle.classList.add('closed');
  }
}

function clearConsole() {
  consoleLines.length = 0;
  renderConsole();
}

// Log all fetch requests
const originalFetch = window.fetch;
window.fetch = async function(...args) {
  const url = args[0];
  const options = args[1] || {};

  logToConsole(`‚Üí ${options.method || 'GET'} ${url}`, 'info');

  try {
    const response = await originalFetch.apply(this, args);
    const clonedResponse = response.clone();

    try {
      const data = await clonedResponse.json();
      if (response.ok) {
        logToConsole(`‚Üê ${response.status} ${url}: ${JSON.stringify(data).substr(0, 100)}`, 'success');
      } else {
        logToConsole(`‚Üê ${response.status} ${url}: ${JSON.stringify(data).substr(0, 100)}`, 'error');
      }
    } catch(e) {
      logToConsole(`‚Üê ${response.status} ${url}: (non-JSON response)`, response.ok ? 'success' : 'error');
    }

    return response;
  } catch(error) {
    logToConsole(`‚úó ${url}: ${error.message}`, 'error');
    throw error;
  }
};

// Initialize console on load
window.addEventListener('DOMContentLoaded', () => {
  logToConsole('Fleet Management Console initialized', 'success');
});
</script>

<!-- Logs Modal -->
<div id="logsModal" class="modal" style="display:none">
  <div class="modal-content" style="max-width:900px;max-height:80vh">
    <div class="modal-header" style="display:flex;align-items:center;justify-content:space-between">
      <div style="display:flex;align-items:center;gap:16px">
        <h3 id="logsModalTitle">üìù Device Logs</h3>
        <div style="display:flex;gap:8px">
          <button id="logsTabActivity" onclick="switchLogsTab('activity')" class="btn-secondary" style="padding:6px 12px;font-size:14px">Activity (7d)</button>
          <button id="logsTabDevice" onclick="switchLogsTab('device')" class="btn-secondary" style="padding:6px 12px;font-size:14px">Device RAM</button>
        </div>
      </div>
      <button onclick="closeLogsModal()" style="background:none;border:none;font-size:24px;cursor:pointer;padding:0">√ó</button>
    </div>
    <div class="modal-body" style="max-height:60vh;overflow-y:auto">
      <div id="logsContent" style="font-family:monospace;font-size:13px;line-height:1.6;white-space:pre-wrap;background:#1e1e1e;color:#d4d4d4;padding:16px;border-radius:8px;overflow-x:auto"></div>
    </div>
    <div class="modal-footer">
      <button onclick="closeLogsModal()" class="btn-secondary">Close</button>
    </div>
  </div>
</div>

<!-- Debug Console -->
<button id="consoleToggle" class="console-toggle" onclick="toggleConsole()">‚ñ≤ Show Console</button>

<div id="debugConsole" class="debug-console" style="display:none">
  <div class="console-header">
    <h4>üêõ Debug Console</h4>
    <div>
      <button onclick="clearConsole()" style="padding:4px 12px;margin-right:8px;background:#444;color:#fff;border:none;border-radius:4px;cursor:pointer">Clear</button>
      <button onclick="toggleConsole()" style="padding:4px 12px;background:#444;color:#fff;border:none;border-radius:4px;cursor:pointer">Close</button>
    </div>
  </div>
  <div id="consoleBody" class="console-body"></div>
</div>

</body>
</html>
