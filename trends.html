<!doctype html><html><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"><title>Polivalka ‚Äî Trends</title>
<script src="api-adapter.js"></script>
<style>
    body{font-family:system-ui,Arial;margin:0;padding:0;max-width:100%}
    .header{position:sticky;top:0;z-index:1000;background:#2c5f2d;color:#fff;padding:8px 10px;display:flex;justify-content:space-between;align-items:center;gap:8px}
    .header h1{margin:0;font-size:18px}
    .header-info{font-size:12px;text-align:right;line-height:1.3}
    .nav{position:sticky;top:65px;z-index:999;background:#f0f0f0;padding:5px 8px;display:flex;gap:2px;border-bottom:1px solid #ddd;overflow-x:auto;white-space:nowrap;-webkit-overflow-scrolling:touch}
    .nav a{text-decoration:none;color:#333;padding:6px 8px;border-radius:6px;font-size:14px;flex-shrink:0}
    .nav a.active{background:#2c5f2d;color:#fff}
    .nav a:hover{background:#ddd}
    .container{padding:18px;max-width:760px}
    .card{border:1px solid #ddd;padding:16px;border-radius:12px;margin:12px 0}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .mono{font-family:ui-monospace,monospace}
    button{padding:8px 12px;border-radius:8px;border:1px solid #888;background:#fafafa;cursor:pointer}
    button.primary{background:#2c5f2d;color:#fff;border-color:#2c5f2d}
    .muted{color:#666;font-size:14px}
    .danger{color:#b00}
    .ok{color:#0a0}
    .status-badge{display:inline-block;padding:4px 10px;border-radius:12px;font-size:13px;font-weight:600}
    .status-timer{background:#e3f2fd;color:#1976d2}
    .status-sensor{background:#fff3e0;color:#f57c00}
    .status-off{background:#fce4ec;color:#c2185b}
    .event-row{padding:8px 12px;margin:4px 0;border-radius:6px;font-size:13px;font-family:ui-monospace,monospace}
    .event-INFO{background:#f5f5f5;border-left:3px solid #666}
    .event-WATERING{background:#e3f2fd;border-left:3px solid #1976d2}
    .event-ERROR{background:#ffebee;border-left:3px solid #c62828}
    .event-CONFIG{background:#fff3e0;border-left:3px solid #f57c00}
  </style>
</head><body><div class="header"><div><h1 id="device-name" style="margin:0;font-size:18px">üå± Polivalka</h1><div style="font-size:11px;opacity:0.8"><span id="location-text">‚Äî</span> / <span id="room-text">‚Äî</span></div></div><div class="header-info"><div id="header-time" class="mono" style="font-size:11px">Time: --:--</div><div style="font-size:11px" id="header-mode">Mode: <span id="mode-badge" class="status-badge status-off">Off</span></div><div style="font-size:11px" id="header-conn">üì° <span id="conn-text">Offline</span></div></div></div></div><div class="nav"><a href="home.html">Home</a><a href="timer.html">Timer</a><a href="sensor.html">Sensor</a><a href="settings.html">Settings</a><a href="calibration.html">Calibration</a><a href="online.html">Online</a><a href="trends.html" class="active">Trends</a><a href="update.html">Update</a></div><div class="container"><div class="card"><h3>üìù Device Logs</h3><p class="muted">View system events and diagnostics (reboot-persistent)</p><div class="row" style="margin-bottom:16px"><button class="primary" onclick="downloadLogs()">üì• Download logs.txt</button><button onclick="loadLogs()">üîÑ Refresh</button></div><div style="background:#f9f9f9;padding:12px;border-radius:8px;margin-bottom:12px"><div><b>Reboot Count:</b> <span id="reboot-count" class="mono">‚Äî</span></div></div><div id="logs-container"><div class="muted">Loading logs...</div></div></div></div>
<script>
// Minimal header updates only
async function updateTime(){
  try {
    const t = await API.get('/time/status');
    const timeEl = document.getElementById('header-time');
    if (t.time_set && t.current_time) {
      timeEl.textContent='Time: '+t.current_time.substring(11,16);
      timeEl.className = 'mono ok';
    } else {
      timeEl.textContent = 'Time: not set';
      timeEl.className = 'mono danger';
    }
  } catch(e) {}
}

async function updateMode(){
  try {
    const s = await API.get('/status');
    if (s.system_state?.device_name) {
      document.getElementById('device-name').textContent = 'üå± ' + s.system_state.device_name;
    }
    if (s.system_state?.location) {
      document.getElementById('location-text').textContent = s.system_state.location;
    }
    if (s.system_state?.room) {
      document.getElementById('room-text').textContent = s.system_state.room;
    }
    const mode = s.system_state?.mode || 'off';
    const modeBadge = document.getElementById('mode-badge');
    const modeText = mode.charAt(0).toUpperCase() + mode.slice(1);
    modeBadge.textContent = modeText;
    modeBadge.className = 'status-badge status-' + mode;

    // Connection status
    const connText = document.getElementById('conn-text');
    if (s.wifi_connected) {
      connText.textContent = 'Online';
      connText.style.color = '#0a0';
    } else {
      connText.textContent = 'Offline';
      connText.style.color = '#999';
    }
  } catch(e) {}
}

// Cloud mode: –ø–æ–∫–∞–∑–∞—Ç—å device ID –≤ header —Å—Ä–∞–∑—É
if (IS_CLOUD && DEVICE_ID) {
  document.getElementById('device-name').textContent = `üå± Polivalka-${DEVICE_ID}`;
  document.title = `Polivalka-${DEVICE_ID} ‚Äî Trends`;
  document.getElementById('location-text').textContent = 'Cloud';
  document.getElementById('room-text').textContent = DEVICE_ID;
}

updateTime();
updateMode();

// Track WiFi mode to detect disconnection
var lastWiFiMode = null;
var lastStaIp = null;

async function monitorWiFiMode() {
  try {
    const response = await fetch('/api/wifi/status', {
      method: 'POST',
      cache: 'no-store'
    });
    const result = await response.json();
    const currentMode = result.mode;
    const currentStaIp = result.sta_ip || null;

    // Initialize on first call
    if (lastWiFiMode === null) {
      lastWiFiMode = currentMode;
      lastStaIp = currentStaIp;
      return;
    }

    // Detect NEW connection to router (sta_ip appeared) - redirect immediately!
    if (!lastStaIp && currentStaIp) {
      console.log('Connected to router, redirecting to ' + currentStaIp);
      window.location.href = 'http://' + currentStaIp + window.location.pathname;
      return;
    }

    if (lastWiFiMode && (lastWiFiMode === 'sta' || lastWiFiMode === 'apsta') && currentMode === 'ap') {
      console.log('WiFi disconnected, redirecting to AP mode...');
      window.location.href = 'http://192.168.4.1' + window.location.pathname;
      return;
    }

    lastWiFiMode = currentMode;
    lastStaIp = currentStaIp;
  } catch(e) {
    // Connection lost - try AP fallback
    console.log('Connection lost, trying AP fallback...');
    try {
      await fetch('http://192.168.4.1/api/wifi/status', {
        method: 'POST',
        cache: 'no-store'
      });
      // AP is accessible - redirect
      console.log('AP accessible, redirecting...');
      window.location.href = 'http://192.168.4.1' + window.location.pathname;
    } catch(e2) {
      // AP not accessible yet, will retry on next poll
    }
  }
}

async function loadLogs() {
  try {
    const data = await fetch('/logs', {cache: 'no-store'}).then(r => r.json());

    // Update reboot count
    document.getElementById('reboot-count').textContent = data.reboot_count || 0;

    const container = document.getElementById('logs-container');
    let html = '';

    // Critical logs (NVS - persistent)
    if (data.critical && data.critical.length > 0) {
      html += '<h4 style="margin-top:0">Critical Events (NVS - Persistent)</h4>';
      for (const entry of data.critical) {
        const timeStr = entry.time > 0 ? new Date(entry.time * 1000).toLocaleString() : 'time not set';
        const eventClass = entry.event.includes('ERROR') ? 'event-ERROR' :
                          entry.event.includes('PUMP') || entry.event.includes('WATERING') ? 'event-WATERING' :
                          entry.event.includes('CALIBRAT') || entry.event.includes('CONFIG') ? 'event-CONFIG' : 'event-INFO';
        html += `<div class="event-row ${eventClass}">[${timeStr}] ${entry.event}</div>`;
      }
    } else {
      html += '<div class="muted">No critical events yet</div>';
    }

    // RAM logs
    if (data.ram && data.ram.length > 0) {
      html += '<h4 style="margin-top:20px">RAM Logs (Last 100, lost on reboot)</h4>';
      for (const entry of data.ram) {
        const sec = Math.floor(entry.ms / 1000);
        const ms = entry.ms % 1000;
        const timeStr = `+${sec}.${ms.toString().padStart(3,'0')}s`;
        const eventClass = entry.event.includes('ERROR') ? 'event-ERROR' :
                          entry.event.includes('PUMP') || entry.event.includes('WATERING') ? 'event-WATERING' :
                          entry.event.includes('CALIBRAT') || entry.event.includes('CONFIG') ? 'event-CONFIG' : 'event-INFO';
        html += `<div class="event-row ${eventClass}">[${timeStr}] ${entry.event}</div>`;
      }
    } else {
      html += '<div class="muted">No RAM logs yet</div>';
    }

    container.innerHTML = html;
  } catch (e) {
    console.error('Failed to load logs:', e);
    document.getElementById('logs-container').innerHTML = '<div class="danger">Failed to load logs</div>';
  }
}

function downloadLogs() {
  window.location.href = '/api/logs/download';
}

// Auto-update intervals
setInterval(updateTime, 60000);      // Time: every minute
setInterval(updateMode, 30000);      // Status/Mode: every 30 seconds
if (!IS_CLOUD) { setInterval(monitorWiFiMode, 10000);  // WiFi mode: every 10 seconds

// Initial load
monitorWiFiMode();
loadLogs();
</script>
</body></html>
