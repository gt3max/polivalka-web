<!doctype html><html><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"><title>PlantApp ‚Äî Admin</title>
<link rel="icon" href="favicon.svg" type="image/svg+xml">
<script src="api-adapter.js"></script>
<script src="common.js"></script>
<style>
    body{font-family:system-ui,Arial;margin:0;padding:0;max-width:100%;background:#1a1a2e}
    .header{position:sticky;top:0;z-index:1000;background:#b00;color:#fff;padding:8px 10px;display:flex;justify-content:space-between;align-items:center;gap:8px}
    .header h1{margin:0;font-size:18px}
    .header-info{font-size:12px;text-align:right;line-height:1.3}
    .container{padding:18px;max-width:760px;margin:0 auto}
    .card{border:1px solid #333;padding:16px;border-radius:12px;margin:12px 0;background:#252540}
    .card h3{color:#fff;margin-top:0}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .mono{font-family:ui-monospace,monospace}
    button{padding:8px 12px;border-radius:8px;border:1px solid #888;background:#fafafa;cursor:pointer}
    button.primary{background:#2c5f2d;color:#fff;border-color:#2c5f2d}
    button.danger{background:#b00;color:#fff;border-color:#900}
    input[type="number"]{padding:8px 10px;border:1px solid #555;border-radius:8px;background:#1a1a2e;color:#fff;width:80px;font-size:16px}
    .muted{color:#999;font-size:14px}
    .danger{color:#f44}
    .ok{color:#4f4}
    .warning-banner{background:#ff9800;color:#000;padding:12px;text-align:center;font-weight:600}

    /* Toggle switch */
    .toggle-row{display:flex;justify-content:space-between;align-items:center;padding:12px 0;border-bottom:1px solid #333}
    .toggle-row:last-child{border-bottom:none}
    .toggle-label{color:#fff}
    .toggle-desc{color:#999;font-size:12px;margin-top:2px}
    .toggle-switch{position:relative;display:inline-block;width:51px;height:31px;flex-shrink:0}
    .toggle-switch input{opacity:0;width:0;height:0}
    .toggle-slider{position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background:#555;border-radius:31px;transition:0.3s}
    .toggle-slider:before{position:absolute;content:"";height:27px;width:27px;left:2px;bottom:2px;background:#fff;border-radius:50%;transition:0.3s}
    input:checked+.toggle-slider{background:#4caf50}
    input:checked+.toggle-slider:before{transform:translateX(20px)}

    /* Section headers */
    .section-header{color:#ff9800;font-size:12px;font-weight:600;text-transform:uppercase;letter-spacing:1px;margin-bottom:12px;padding-bottom:8px;border-bottom:1px solid #333}

    /* Status indicator */
    .status-dot{display:inline-block;width:8px;height:8px;border-radius:50%;margin-right:6px}
    .status-dot.online{background:#4caf50}
    .status-dot.offline{background:#f44}

    /* Device selector */
    select{padding:8px 12px;border:1px solid #555;border-radius:8px;background:#1a1a2e;color:#fff;font-size:14px;width:100%;max-width:300px}

    /* Info list (read-only) */
    .info-list{margin-top:12px}
    .info-row{display:flex;justify-content:space-between;padding:8px 0;border-bottom:1px solid #333}
    .info-row:last-child{border-bottom:none}
    .info-label{color:#ccc}
    .info-value{color:#4caf50;font-family:ui-monospace,monospace}
</style>
</head><body>
<div class="warning-banner">ADMIN PANEL ‚Äî NOT FOR USERS</div>
<div class="header">
<div style="display:flex;align-items:center;gap:12px">
  <a id="back-link" href="/" style="color:#fff;text-decoration:none;font-size:14px">‚Üê Fleet</a>
  <div><h1 style="margin:0">üîß Admin Panel</h1><div style="font-size:11px;opacity:0.8">AWS IoT Configuration</div></div>
</div>
<div class="header-info"><div class="mono" style="font-size:11px"><span class="status-dot" id="aws-status-dot"></span><span id="aws-status">Checking...</span></div></div>
</div>

<div class="container">

<!-- Device Selector -->
<div class="card">
<h3>üì± Select Device</h3>
<select id="device-select" onchange="loadDeviceConfig()">
<option value="">Loading devices...</option>
</select>
<div id="device-info" style="margin-top:12px;display:none">
<div class="muted">Device ID: <span id="selected-device-id" class="mono">‚Äî</span></div>
<div class="muted">Last seen: <span id="selected-device-lastseen" class="mono">‚Äî</span></div>
</div>
</div>

<!-- Device Stats (–ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è –ø–æ—Å–ª–µ –≤—ã–±–æ—Ä–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞) -->
<div class="card" id="device-stats-card" style="display:none">
<h3>üìä Device Stats</h3>
<div class="info-list">
<div class="info-row"><span class="info-label">Firmware</span><span class="info-value" id="stat-firmware">‚Äî</span></div>
</div>

<div class="section-header" style="margin-top:16px">Restarts</div>
<div class="info-list">
<div class="info-row">
  <span class="info-label">Total (all time)</span>
  <span class="info-value" id="stat-reboot-count" style="font-weight:600">‚Äî</span>
</div>
<div class="info-row" style="padding-left:16px;border-bottom:none">
  <span class="muted" style="font-size:11px">Historical total since device first boot</span>
</div>
<div class="info-row">
  <span class="info-label">Planned restarts</span>
  <span class="info-value" id="stat-clean-restarts">‚Äî</span>
</div>
<div class="info-row" style="padding-left:16px;border-bottom:none">
  <span class="muted" style="font-size:11px">OTA updates, reboot commands (since v1.0.10+)</span>
</div>
<div class="info-row">
  <span class="info-label">Unplanned restarts</span>
  <span class="info-value" id="stat-unexpected-restarts" style="color:#ff9800">‚Äî</span>
</div>
<div class="info-row" style="padding-left:16px;border-bottom:none">
  <span class="muted" style="font-size:11px">USB flash, power loss, crash, watchdog (since v1.0.10+)</span>
</div>
</div>
<div class="row" style="margin-top:8px">
<button onclick="resetStats('restarts')">Reset Counters</button>
</div>

<div class="section-header" style="margin-top:16px">Pump & Water</div>
<div class="info-list">
<div class="info-row"><span class="info-label">Total Water</span><span class="info-value" id="stat-total-water">‚Äî ml</span></div>
<div class="info-row"><span class="info-label">Pump Runtime</span><span class="info-value" id="stat-pump-runtime">‚Äî sec</span></div>
</div>
<div class="row" style="margin-top:8px">
<button onclick="resetStats('pump')">Reset Pump Stats</button>
</div>
</div>

<!-- Periodic Telemetry (Info only - hardcoded in firmware) -->
<div class="card">
<h3>üìä Periodic Telemetry</h3>
<p class="muted">Intervals are hardcoded in firmware (app_main.c). To change, reflash device.</p>
<div class="info-list">
<div class="info-row"><span class="info-label">Sensor Telemetry</span><span class="info-value">60 min</span></div>
<div class="info-row"><span class="info-label">Battery Telemetry</span><span class="info-value">60 min</span></div>
<div class="info-row"><span class="info-label">System Heartbeat</span><span class="info-value">30 min</span></div>
</div>
</div>

<!-- Event Telemetry (Info only) -->
<div class="card">
<h3>‚ö° Event Telemetry</h3>
<p class="muted">Events published to AWS IoT when triggered (not configurable).</p>
<div class="info-list">
<div class="info-row"><span class="info-label">Pump Events</span><span class="info-value">On start/stop</span></div>
<div class="info-row"><span class="info-label">Config Changes</span><span class="info-value">On save</span></div>
<div class="info-row"><span class="info-label">Command Responses</span><span class="info-value">On command</span></div>
</div>
</div>

<!-- Factory Presets -->
<div class="card">
<h3>üìã Factory Presets</h3>
<p class="muted">Default values for uncalibrated devices. User's physical calibration (Calibration page) takes priority.</p>

<div class="section-header">Pump Preset</div>
<div class="toggle-row">
<div><div class="toggle-label">Default Flow Rate</div><div class="toggle-desc">Used if pump not calibrated <span class="mono">(ml_per_sec)</span></div></div>
<div class="row"><input type="number" id="calib-pump-mlsec" min="0.1" max="50" step="0.1" value="2.5" style="width:80px"><span class="muted">ml/sec</span></div>
</div>
<div class="row" style="margin-top:8px">
<button onclick="savePumpPreset()">Set Pump Preset</button>
</div>

<div class="section-header" style="margin-top:20px">Sensor Preset (ADC values)</div>
<div class="toggle-row">
<div><div class="toggle-label">ADC Water</div><div class="toggle-desc">Default 100% moisture <span class="mono">(adc_water)</span></div></div>
<div class="row"><input type="number" id="calib-adc-water" min="0" max="4095" value="1200" style="width:80px"></div>
</div>
<div class="toggle-row">
<div><div class="toggle-label">ADC Dry Soil</div><div class="toggle-desc">Default 0% moisture <span class="mono">(adc_dry_soil)</span></div></div>
<div class="row"><input type="number" id="calib-adc-dry" min="0" max="4095" value="2800" style="width:80px"></div>
</div>
<div class="toggle-row">
<div><div class="toggle-label">ADC Air</div><div class="toggle-desc">Default air reference <span class="mono">(adc_air)</span></div></div>
<div class="row"><input type="number" id="calib-adc-air" min="0" max="4095" value="3200" style="width:80px"></div>
</div>
<div class="row" style="margin-top:8px">
<button onclick="saveSensorPreset()">Set Capacitive Preset</button>
</div>

<div class="section-header" style="margin-top:20px">Resistive Sensor Preset (2-point)</div>
<div class="toggle-row">
<div><div class="toggle-label">ADC Dry Soil</div><div class="toggle-desc">Default 0% moisture <span class="mono">(adc_s2_dry)</span></div></div>
<div class="row"><input type="number" id="calib-s2-dry" min="0" max="4095" value="4095" style="width:80px"></div>
</div>
<div class="toggle-row">
<div><div class="toggle-label">ADC Wet Soil</div><div class="toggle-desc">Default 100% moisture <span class="mono">(adc_s2_wet)</span></div></div>
<div class="row"><input type="number" id="calib-s2-wet" min="0" max="4095" value="1000" style="width:80px"></div>
</div>
<div class="row" style="margin-top:8px">
<button onclick="saveSensor2Preset()">Set Resistive Preset</button>
</div>
</div>

<!-- WiFi Settings -->
<div class="card">
<h3>üì∂ WiFi Settings</h3>
<p class="muted">WiFi reconnect behavior when connection is lost.</p>

<div class="section-header">Phase 2: Periodic Scan</div>
<div class="toggle-row">
<div><div class="toggle-label">Scan Interval</div><div class="toggle-desc">How often to scan for saved WiFi when disconnected <span class="mono">(wifi_scan_interval_hours)</span></div></div>
<div class="row"><input type="number" id="wifi-scan-interval" min="1" max="168" value="24" style="width:80px"><span class="muted">hours</span></div>
</div>
<div class="row" style="margin-top:8px">
<button onclick="saveWifiSettings()">Set WiFi Settings</button>
</div>
<div class="muted" style="margin-top:12px;font-size:12px">
üí° Phase 1 (immediate): 5 reconnect attempts √ó 30 sec<br>
üí° Phase 2 (long-term): Scan every N hours until WiFi returns
</div>
</div>

<!-- Microprime Settings -->
<div class="card">
<h3>üíß Microprime (Maintenance Pulse)</h3>
<p class="muted">Short pump pulse to prevent water stagnation in tubing. Runs during 09:00-23:00.</p>

<div class="toggle-row">
<div><div class="toggle-label">Interval</div><div class="toggle-desc">How often to run maintenance pulse (0 = disabled) <span class="mono">(microprime_interval_hours)</span></div></div>
<div class="row"><input type="number" id="microprime-interval" min="0" max="168" value="24" style="width:80px"><span class="muted">hours</span></div>
</div>
<div class="row" style="margin-top:8px">
<button onclick="saveMicroprimeSettings()">Set Microprime</button>
</div>
<div class="muted" style="margin-top:12px;font-size:12px">
üí° Pulse duration: 4 seconds (hardcoded)<br>
üí° Only runs in Sensor Mode<br>
üí° Set to 0 to disable
</div>
</div>

<!-- Costs Estimate -->
<div class="card">
<h3>üí∞ AWS Cost Estimate</h3>
<p class="muted">Based on current settings</p>
<div id="cost-estimate" style="color:#fff;font-size:14px">
<div>Messages/month: <span id="est-messages" class="mono ok">‚Äî</span></div>
<div>Within Free Tier: <span id="est-free-tier" class="mono">‚Äî</span></div>
<div>Estimated cost: <span id="est-cost" class="mono">‚Äî</span></div>
</div>
</div>

<!-- Device History (shows when device selected) -->
<div class="card" id="device-history-card" style="display:none">
<div style="display:flex;justify-content:space-between;align-items:center;cursor:pointer" onclick="toggleHistorySection()">
  <h3 style="margin:0">üìú Device History</h3>
  <span id="history-toggle-icon" style="color:#fff;font-size:18px">‚ñ∂</span>
</div>
<div id="device-history-content" style="display:none;margin-top:12px">
  <div id="device-history-list">
    <div class="muted">No history</div>
  </div>
</div>
</div>

<!-- Pending Claims -->
<div class="card" id="pending-claims-card">
<div style="display:flex;justify-content:space-between;align-items:center;cursor:pointer" onclick="togglePendingSection()">
  <h3 style="margin:0">‚è≥ Pending Claims <span id="pending-count" style="background:#ff9800;color:#000;padding:2px 8px;border-radius:12px;font-size:12px;margin-left:8px">0</span></h3>
  <span id="pending-toggle-icon" style="color:#fff;font-size:18px">‚ñ∂</span>
</div>
<div id="pending-claims-content" style="display:none;margin-top:12px">
  <p class="muted">Users requesting to claim devices (not in whitelist)</p>
  <div id="pending-claims-list">
    <div class="muted">No pending claims</div>
  </div>
</div>
</div>

<!-- Registered Users -->
<div class="card">
<h3>üë• Registered Users</h3>
<p class="muted">All users with accounts on the platform</p>
<div id="users-list" style="margin-top:12px">
<div class="muted">Loading...</div>
</div>
</div>

<!-- Archived Devices -->
<div class="card">
<h3>üóÑÔ∏è Archived Devices</h3>
<p class="muted">Hidden from Fleet but still receiving data if online</p>
<div id="archived-list" style="margin-top:12px">
<div class="muted">Loading...</div>
</div>
</div>

<!-- Deleted Devices -->
<div class="card">
<h3>üóëÔ∏è Deleted Devices</h3>
<p class="muted">Certificate deactivated, cannot connect to cloud</p>
<div id="deleted-list" style="margin-top:12px">
<div class="muted">Loading...</div>
</div>
</div>

<!-- Danger Zone -->
<div class="card" style="border-color:#b00;background:#2a1a1a">
<h3 style="color:#f44">‚ö†Ô∏è DANGER ZONE</h3>
<p class="muted">Actions below affect the selected device. Use with caution.</p>

<div style="margin-top:16px;display:flex;gap:12px;flex-wrap:wrap">
<button class="danger" onclick="archiveDevice()" id="btn-archive" disabled style="opacity:0.5">
üóÑÔ∏è Archive Device
</button>
<button class="danger" onclick="deleteDevice()" id="btn-delete" disabled style="opacity:0.5">
üóëÔ∏è Delete Device
</button>
</div>
<p class="muted" style="margin-top:12px;font-size:11px">
<b>Archive:</b> Hides from Fleet, device keeps working.<br>
<b>Delete:</b> Deactivates certificate, device cannot connect to cloud.
</p>
</div>

</div>

<script>
let selectedDeviceId = null;

// ============ Lambda API –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –¥–∞–Ω–Ω—ã–º–∏ (Security Migration 2026-01-20) ============
// –î–∞–Ω–Ω—ã–µ —Ç–µ–ø–µ—Ä—å —Ö—Ä–∞–Ω—è—Ç—Å—è –≤ DynamoDB, –¥–æ—Å—Ç—É–ø —á–µ—Ä–µ–∑ Lambda API —Å JWT –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–µ–π

// ============ Whitelist –æ–ø–µ—Ä–∞—Ü–∏–∏ (—á–µ—Ä–µ–∑ Lambda API) ============
let whitelistData = null;

async function loadWhitelist() {
  try {
    const res = await fetch(`${API.cloudBase}/admin/whitelist`, {
      headers: API.getAuthHeaders(),
      cache: 'no-store'
    });
    if (!res.ok) throw new Error((await res.json().catch(() => ({}))).error || res.status);
    whitelistData = await res.json();
    return whitelistData;
  } catch (e) {
    console.error('[Admin] Error loading whitelist:', e);
    whitelistData = { users: {} };
    return whitelistData;
  }
}

async function saveWhitelist(message) {
  // saveWhitelist —Ç–µ–ø–µ—Ä—å –Ω–µ –Ω—É–∂–µ–Ω - –∫–∞–∂–¥–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è –¥–µ–ª–∞–µ—Ç—Å—è –æ—Ç–¥–µ–ª—å–Ω—ã–º API –∑–∞–ø—Ä–æ—Å–æ–º
  // –≠—Ç–æ—Ç –º–µ—Ç–æ–¥ –æ—Å—Ç–∞–≤–ª–µ–Ω –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏, –Ω–æ —Ç–µ–ø–µ—Ä—å –ø—Ä–æ—Å—Ç–æ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ
  console.log('[Admin] saveWhitelist called (now uses individual API calls):', message);
  await loadWhitelist();
  return true;
}

async function addUserToWhitelist(email, data) {
  try {
    const res = await fetch(`${API.cloudBase}/admin/whitelist`, {
      method: 'POST',
      headers: { ...API.getAuthHeaders(), 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, status: data.status || 'active', devices: data.devices || [] })
    });
    if (!res.ok) throw new Error((await res.json().catch(() => ({}))).error || res.status);
    return true;
  } catch (e) {
    console.error('[Admin] Error adding to whitelist:', e);
    alert('Error: ' + e.message);
    return false;
  }
}

async function updateUserInWhitelist(email, data) {
  try {
    const res = await fetch(`${API.cloudBase}/admin/whitelist/${encodeURIComponent(email)}`, {
      method: 'PUT',
      headers: { ...API.getAuthHeaders(), 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });
    if (!res.ok) throw new Error((await res.json().catch(() => ({}))).error || res.status);
    return true;
  } catch (e) {
    console.error('[Admin] Error updating whitelist:', e);
    alert('Error: ' + e.message);
    return false;
  }
}

async function removeUserFromWhitelist(email) {
  try {
    const res = await fetch(`${API.cloudBase}/admin/whitelist/${encodeURIComponent(email)}`, {
      method: 'DELETE',
      headers: API.getAuthHeaders()
    });
    if (!res.ok) throw new Error((await res.json().catch(() => ({}))).error || res.status);
    return true;
  } catch (e) {
    console.error('[Admin] Error removing from whitelist:', e);
    alert('Error: ' + e.message);
    return false;
  }
}

// ============ Device History –æ–ø–µ—Ä–∞—Ü–∏–∏ (—á–µ—Ä–µ–∑ Lambda API) ============
let historyData = null;

async function loadDeviceHistory() {
  // –¢–µ–ø–µ—Ä—å –∑–∞–≥—Ä—É–∂–∞–µ—Ç—Å—è per-device —á–µ—Ä–µ–∑ API
  historyData = { devices: {} };
  return historyData;
}

async function loadDeviceHistoryFor(deviceId) {
  try {
    // Use full device_id format (Polivalka-BC67E9) - standardized everywhere
    const res = await fetch(`${API.cloudBase}/admin/history/${deviceId}`, {
      headers: API.getAuthHeaders(),
      cache: 'no-store'
    });
    if (!res.ok) throw new Error((await res.json().catch(() => ({}))).error || res.status);
    const data = await res.json();
    return data.events || [];
  } catch (e) {
    console.error('[Admin] Error loading device history:', e);
    return [];
  }
}

async function addDeviceHistoryEntry(deviceId, event) {
  try {
    // Use full device_id format (Polivalka-BC67E9) - standardized everywhere
    const res = await fetch(`${API.cloudBase}/admin/history`, {
      method: 'POST',
      headers: { ...API.getAuthHeaders(), 'Content-Type': 'application/json' },
      body: JSON.stringify({
        device_id: deviceId,
        event: event.event,
        user_email: event.to || event.from || event.by
      })
    });
    if (!res.ok) throw new Error((await res.json().catch(() => ({}))).error || res.status);
    return true;
  } catch (e) {
    console.error('[Admin] Error adding history:', e);
    return false;
  }
}

// ============ Pending Claims –æ–ø–µ—Ä–∞—Ü–∏–∏ (—á–µ—Ä–µ–∑ Lambda API) ============
let pendingData = null;

async function loadPendingClaims() {
  try {
    const res = await fetch(`${API.cloudBase}/admin/claims`, {
      headers: API.getAuthHeaders(),
      cache: 'no-store'
    });
    if (!res.ok) throw new Error((await res.json().catch(() => ({}))).error || res.status);
    pendingData = await res.json();
    return pendingData;
  } catch (e) {
    console.error('[Admin] Error loading claims:', e);
    pendingData = { claims: [] };
    return pendingData;
  }
}

async function savePendingClaims(message) {
  // –¢–µ–ø–µ—Ä—å –Ω–µ –Ω—É–∂–µ–Ω - –∫–∞–∂–¥–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è –¥–µ–ª–∞–µ—Ç—Å—è –æ—Ç–¥–µ–ª—å–Ω—ã–º API –∑–∞–ø—Ä–æ—Å–æ–º
  console.log('[Admin] savePendingClaims called (now uses individual API calls):', message);
  await loadPendingClaims();
  return true;
}

async function deleteClaim(claimId) {
  try {
    const res = await fetch(`${API.cloudBase}/admin/claims/${claimId}`, {
      method: 'DELETE',
      headers: API.getAuthHeaders()
    });
    if (!res.ok) throw new Error((await res.json().catch(() => ({}))).error || res.status);
    return true;
  } catch (e) {
    console.error('[Admin] Error deleting claim:', e);
    return false;
  }
}

// Load device list - call /devices directly (no device prefix!)
async function loadDevices() {
  console.log('[Admin] Loading devices...');
  try {
    // Call API directly without device prefix (admin needs ALL devices, not device-specific)
    const url = `${API.cloudBase}/devices`;
    const res = await fetch(url, {
      headers: API.getAuthHeaders(),
      cache: 'no-store'
    });
    if (!res.ok) throw new Error((await res.json().catch(() => ({}))).error || res.status);
    const devices = await res.json();
    console.log('[Admin] Got devices:', devices);
    const select = document.getElementById('device-select');
    select.innerHTML = '<option value="">‚Äî Select device ‚Äî</option>';

    if (!devices || devices.length === 0) {
      document.getElementById('aws-status').textContent = 'No devices found';
      document.getElementById('aws-status-dot').className = 'status-dot offline';
      return;
    }

    for (const d of devices) {
      const opt = document.createElement('option');
      opt.value = d.device_id;
      // Admin needs device_id, show custom name in parentheses if different
      const shortId = d.device_id.replace('Polivalka-', '');
      const customName = (d.name && d.name !== d.device_id && d.name !== 'Polivalka') ? ` "${d.name}"` : '';
      opt.textContent = shortId + customName + (d.online ? ' (online)' : ' (offline)');
      select.appendChild(opt);
    }

    // Check AWS connection
    document.getElementById('aws-status').textContent = 'Connected (' + devices.length + ' devices)';
    document.getElementById('aws-status-dot').className = 'status-dot online';
  } catch(e) {
    console.error('[Admin] Failed to load devices:', e);
    document.getElementById('aws-status').textContent = 'Error: ' + e.message;
    document.getElementById('aws-status-dot').className = 'status-dot offline';
    document.getElementById('device-select').innerHTML = '<option value="">Error loading devices</option>';
  }
}

// Load config for selected device
async function loadDeviceConfig() {
  const deviceId = document.getElementById('device-select').value;
  if (!deviceId) {
    document.getElementById('device-info').style.display = 'none';
    document.getElementById('device-stats-card').style.display = 'none';
    document.getElementById('device-history-card').style.display = 'none';
    updateDangerButtons(false);
    return;
  }

  selectedDeviceId = deviceId;
  document.getElementById('selected-device-id').textContent = deviceId;
  updateDangerButtons(true);  // Enable Archive/Delete buttons
  document.getElementById('device-info').style.display = 'block';
  document.getElementById('device-stats-card').style.display = 'block';
  document.getElementById('selected-device-lastseen').textContent = 'Loading...';

  // Fetch current device data to populate fields
  try {
    const res = await fetch(`${API.cloudBase}/devices`, {
      headers: API.getAuthHeaders(),
      cache: 'no-store'
    });
    if (res.ok) {
      const devices = await res.json();
      const device = devices.find(d => d.device_id === deviceId);
      if (device) {
        // Populate pump calibration (from DynamoDB)
        const pumpCalib = device.pump_calibration || 2.5;
        document.getElementById('calib-pump-mlsec').value = pumpCalib;
        console.log('[Admin] Loaded pump_calibration:', pumpCalib);

        // Populate Capacitive sensor calibration (from DynamoDB)
        const sensorCalib = device.sensor_calibration || {};
        document.getElementById('calib-adc-water').value = sensorCalib.water || 1200;
        document.getElementById('calib-adc-dry').value = sensorCalib.dry_soil || 2400;
        document.getElementById('calib-adc-air').value = sensorCalib.air || 2800;
        console.log('[Admin] Loaded sensor_calibration:', sensorCalib);

        // Populate Resistive sensor calibration (from DynamoDB)
        const sensor2Calib = device.sensor2_calibration || {};
        document.getElementById('calib-s2-dry').value = sensor2Calib.dry || 4095;
        document.getElementById('calib-s2-wet').value = sensor2Calib.wet || 1000;
        console.log('[Admin] Loaded sensor2_calibration:', sensor2Calib);

        // Show last seen info
        if (device.last_update) {
          const lastSeen = new Date(device.last_update * 1000);
          document.getElementById('selected-device-lastseen').textContent = 'Last update: ' + lastSeen.toLocaleString();
        } else {
          document.getElementById('selected-device-lastseen').textContent = 'Ready for preset changes';
        }

        // Load WiFi scan interval from device data (from system telemetry)
        const wifiScanInterval = device.wifi_scan_interval_hours || device.system?.wifi_scan_interval_hours;
        if (wifiScanInterval) {
          document.getElementById('wifi-scan-interval').value = wifiScanInterval;
          console.log('[Admin] Loaded wifi_scan_interval:', wifiScanInterval);
        }

        // Load microprime interval from sensor config
        const microprimeInterval = device.microprime_interval_hours || device.sensor_config?.microprime_interval_hours;
        if (microprimeInterval !== undefined) {
          document.getElementById('microprime-interval').value = microprimeInterval;
          console.log('[Admin] Loaded microprime_interval:', microprimeInterval);
        }

        // Load Device Stats
        document.getElementById('stat-firmware').textContent = device.firmware_version || '‚Äî';
        document.getElementById('stat-reboot-count').textContent = device.reboot_count ?? '‚Äî';
        document.getElementById('stat-clean-restarts').textContent = device.clean_restarts ?? '‚Äî';
        document.getElementById('stat-unexpected-restarts').textContent = device.unexpected_restarts ?? '‚Äî';
        document.getElementById('stat-total-water').textContent = device.total_water_ml ? device.total_water_ml.toLocaleString() + ' ml' : '‚Äî ml';
        document.getElementById('stat-pump-runtime').textContent = device.pump_runtime_sec ? device.pump_runtime_sec.toLocaleString() + ' sec' : '‚Äî sec';

        console.log('[Admin] Loaded device stats:', {
          firmware: device.firmware_version,
          clean_restarts: device.clean_restarts,
          unexpected_restarts: device.unexpected_restarts,
          total_water_ml: device.total_water_ml,
          pump_runtime_sec: device.pump_runtime_sec
        });
      }
    }
  } catch(e) {
    console.warn('[Admin] Failed to load device data:', e);
    document.getElementById('selected-device-lastseen').textContent = 'Ready for preset changes';
  }

  updateCostEstimate();
  loadDeviceHistoryUI(deviceId);
}

// Load and display device history
async function loadDeviceHistoryUI(deviceId) {
  const card = document.getElementById('device-history-card');
  const container = document.getElementById('device-history-list');
  const shortId = deviceId.replace('Polivalka-', '');

  card.style.display = 'block';
  container.innerHTML = '<div class="muted">Loading...</div>';

  // Load history from Lambda API (not from old GitHub JSON)
  const events = await loadDeviceHistoryFor(deviceId);

  if (events.length === 0) {
    container.innerHTML = '<div class="muted">No history for this device</div>';
    return;
  }

  // Show last 3 events by default, expandable
  const recentEvents = events.slice(-3).reverse();
  const olderEvents = events.slice(0, -3).reverse();

  const formatEvent = (e) => {
    const date = new Date(e.timestamp);
    const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
    let icon = 'üìù';
    let text = e.event;
    // Lambda returns user_email, old format used to/from/by
    const email = e.user_email || e.to || e.from || e.by || 'unknown';
    if (e.event === 'assigned') {
      icon = '‚úÖ';
      text = `Assigned to <span style="color:#4caf50">${email}</span>`;
    } else if (e.event === 'unassigned') {
      icon = '‚ùå';
      text = `Unassigned from <span style="color:#ff9800">${email}</span>`;
    } else if (e.event === 'claimed') {
      icon = 'üîó';
      text = `Claimed by <span style="color:#4caf50">${email}</span>`;
    } else if (e.event === 'provisioned') {
      icon = 'üè≠';
      text = 'Provisioned';
    }
    return `<div style="padding:8px 0;border-bottom:1px solid #444;display:flex;justify-content:space-between;align-items:center">
      <span style="color:#fff;font-size:14px">${icon} ${text}</span>
      <span style="color:#aaa;font-size:12px">${dateStr}</span>
    </div>`;
  };

  let html = recentEvents.map(formatEvent).join('');

  if (olderEvents.length > 0) {
    html += `
      <div id="older-history" style="display:none">
        ${olderEvents.map(formatEvent).join('')}
      </div>
      <button onclick="toggleOlderHistory()" id="btn-older-history" style="font-size:11px;padding:4px 8px;margin-top:8px">
        Show ${olderEvents.length} older events ‚ñº
      </button>
    `;
  }

  container.innerHTML = html;
}

function toggleOlderHistory() {
  const el = document.getElementById('older-history');
  const btn = document.getElementById('btn-older-history');
  if (el.style.display === 'none') {
    el.style.display = 'block';
    btn.textContent = 'Hide older events ‚ñ≤';
  } else {
    el.style.display = 'none';
    const count = el.querySelectorAll('div[style*="border-bottom"]').length;
    btn.textContent = `Show ${count} older events ‚ñº`;
  }
}

function toggleHistorySection() {
  const content = document.getElementById('device-history-content');
  const icon = document.getElementById('history-toggle-icon');
  if (content.style.display === 'none') {
    content.style.display = 'block';
    icon.textContent = '‚ñº';
  } else {
    content.style.display = 'none';
    icon.textContent = '‚ñ∂';
  }
}

function togglePendingSection() {
  const content = document.getElementById('pending-claims-content');
  const icon = document.getElementById('pending-toggle-icon');
  if (content.style.display === 'none') {
    content.style.display = 'block';
    icon.textContent = '‚ñº';
  } else {
    content.style.display = 'none';
    icon.textContent = '‚ñ∂';
  }
}

// ============ Pending Claims UI ============

async function loadPendingClaimsUI() {
  const container = document.getElementById('pending-claims-list');
  const countBadge = document.getElementById('pending-count');

  await loadPendingClaims();

  const claims = pendingData?.claims || [];
  countBadge.textContent = claims.length;

  // Hide badge if no pending claims
  countBadge.style.display = claims.length > 0 ? 'inline' : 'none';

  if (claims.length === 0) {
    container.innerHTML = '<div class="muted">No pending claims</div>';
    return;
  }

  container.innerHTML = claims.map((c, idx) => {
    // Lambda returns created_at, old format used timestamp
    const date = new Date(c.created_at || c.timestamp);
    const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});

    return `
      <div style="padding:12px;background:#1a1a2e;border-radius:8px;margin-bottom:8px">
        <div style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:8px">
          <div>
            <div style="color:#fff;font-size:14px">üì± <span class="mono" style="color:#4caf50">${c.device_id}</span></div>
            <div style="color:#ccc;font-size:13px;margin-top:4px">User: <strong>${c.email}</strong></div>
            <div class="muted" style="font-size:11px;margin-top:2px">Requested: ${dateStr}</div>
          </div>
          <div style="display:flex;gap:8px">
            <button onclick="approveClaim(${idx})" style="background:#4caf50;color:#fff;border-color:#4caf50;font-size:12px;padding:6px 12px">‚úì Approve</button>
            <button onclick="rejectClaim(${idx})" style="background:#f44;color:#fff;border-color:#f44;font-size:12px;padding:6px 12px">‚úó Reject</button>
          </div>
        </div>
      </div>
    `;
  }).join('');
}

async function approveClaim(index) {
  const claim = pendingData.claims[index];
  if (!claim) return;

  if (!confirm(`Approve claim?\n\nDevice: ${claim.device_id}\nUser: ${claim.email}\n\nThis will add user to whitelist and assign the device.`)) return;

  // 1. Add/update user in whitelist with the device
  const existingUser = whitelistData.users?.[claim.email];
  if (existingUser) {
    // User exists - add device to their list
    const devices = existingUser.devices || [];
    if (!devices.includes(claim.device_id)) {
      devices.push(claim.device_id);
    }
    await updateUserInWhitelist(claim.email, { devices });
  } else {
    // New user - add to whitelist with device
    await addUserToWhitelist(claim.email, { devices: [claim.device_id] });
  }

  // 2. Delete the claim
  const claimId = claim.claim_id;
  if (claimId) {
    await deleteClaim(claimId);
  }

  // 3. Add to device history
  await addDeviceHistoryEntry(claim.device_id, {
    event: 'claimed',
    by: claim.email
  });

  showToast(`Claim approved! ${claim.device_id} assigned to ${claim.email}`, 'success');

  // Reload data
  await loadWhitelist();
  await loadPendingClaims();
  loadPendingClaimsUI();
  renderUsersList();
}

async function rejectClaim(index) {
  const claim = pendingData.claims[index];
  if (!claim) return;

  if (!confirm(`Reject claim?\n\nDevice: ${claim.device_id}\nUser: ${claim.email}`)) return;

  // Delete the claim
  const claimId = claim.claim_id;
  if (claimId) {
    const success = await deleteClaim(claimId);
    if (success) {
      showToast(`Claim rejected`, 'warning');
      await loadPendingClaims();
      loadPendingClaimsUI();
    }
  }
}

// Save pump preset (factory default)
async function savePumpPreset() {
  const selectedDeviceId = document.getElementById('device-select').value;
  if (!selectedDeviceId) {
    alert('Please select a device first');
    return;
  }

  const mlPerSec = parseFloat(document.getElementById('calib-pump-mlsec').value);
  if (isNaN(mlPerSec) || mlPerSec < 0.1 || mlPerSec > 50) {
    alert('ml/sec must be between 0.1 and 50');
    return;
  }

  try {
    const res = await fetch(`${API.cloudBase}/device/${selectedDeviceId}/command`, {
      method: 'POST',
      headers: { ...API.getAuthHeaders(), 'Content-Type': 'application/json' },
      body: JSON.stringify({
        command: 'set_pump_preset',
        params: { ml_per_sec: mlPerSec }
      })
    });

    if (res.ok) {
      alert(`‚úì Pump preset set to ${mlPerSec} ml/sec`);
    } else {
      const err = await res.json().catch(() => ({}));
      alert('Failed: ' + (err.error || res.status));
    }
  } catch(e) {
    alert('Error: ' + e.message);
  }
}

// Save sensor preset (factory defaults)
async function saveSensorPreset() {
  const selectedDeviceId = document.getElementById('device-select').value;
  if (!selectedDeviceId) {
    alert('Please select a device first');
    return;
  }

  const adcWater = parseInt(document.getElementById('calib-adc-water').value);
  const adcDry = parseInt(document.getElementById('calib-adc-dry').value);
  const adcAir = parseInt(document.getElementById('calib-adc-air').value);

  if ([adcWater, adcDry, adcAir].some(v => isNaN(v) || v < 0 || v > 4095)) {
    alert('ADC values must be between 0 and 4095');
    return;
  }

  try {
    const res = await fetch(`${API.cloudBase}/device/${selectedDeviceId}/command`, {
      method: 'POST',
      headers: { ...API.getAuthHeaders(), 'Content-Type': 'application/json' },
      body: JSON.stringify({
        command: 'set_sensor_preset',
        params: { adc_water: adcWater, adc_dry_soil: adcDry, adc_air: adcAir }
      })
    });

    if (res.ok) {
      alert(`‚úì Capacitive preset saved: water=${adcWater}, dry=${adcDry}, air=${adcAir}`);
    } else {
      const err = await res.json().catch(() => ({}));
      alert('Failed: ' + (err.error || res.status));
    }
  } catch(e) {
    alert('Error: ' + e.message);
  }
}

// Save Resistive sensor preset
async function saveSensor2Preset() {
  const selectedDeviceId = document.getElementById('device-select').value;
  if (!selectedDeviceId) {
    alert('Please select a device first');
    return;
  }

  const adcDry = parseInt(document.getElementById('calib-s2-dry').value);
  const adcWet = parseInt(document.getElementById('calib-s2-wet').value);

  if ([adcDry, adcWet].some(v => isNaN(v) || v < 0 || v > 4095)) {
    alert('ADC values must be between 0 and 4095');
    return;
  }

  try {
    const res = await fetch(`${API.cloudBase}/device/${selectedDeviceId}/command`, {
      method: 'POST',
      headers: { ...API.getAuthHeaders(), 'Content-Type': 'application/json' },
      body: JSON.stringify({
        command: 'set_sensor2_preset',
        params: { adc_dry: adcDry, adc_wet: adcWet }
      })
    });

    if (res.ok) {
      alert(`‚úì Resistive preset saved: dry=${adcDry}, wet=${adcWet}`);
    } else {
      const err = await res.json().catch(() => ({}));
      alert('Failed: ' + (err.error || res.status));
    }
  } catch(e) {
    alert('Error: ' + e.message);
  }
}

// WiFi settings
async function saveWifiSettings() {
  if (!selectedDeviceId) {
    alert('Select a device first');
    return;
  }

  const scanInterval = parseInt(document.getElementById('wifi-scan-interval').value);

  if (isNaN(scanInterval) || scanInterval < 1 || scanInterval > 168) {
    alert('Scan interval must be between 1 and 168 hours');
    return;
  }

  try {
    const res = await fetch(`${API.cloudBase}/device/${selectedDeviceId}/command`, {
      method: 'POST',
      headers: { ...API.getAuthHeaders(), 'Content-Type': 'application/json' },
      body: JSON.stringify({
        command: 'set_wifi_config',
        params: { wifi_scan_interval_hours: scanInterval }
      })
    });

    if (res.ok) {
      alert(`‚úì WiFi settings saved: scan every ${scanInterval} hours`);
    } else {
      const err = await res.json().catch(() => ({}));
      alert('Failed: ' + (err.error || res.status));
    }
  } catch(e) {
    alert('Error: ' + e.message);
  }
}

// Microprime settings
async function saveMicroprimeSettings() {
  if (!selectedDeviceId) {
    alert('Select a device first');
    return;
  }

  const interval = parseInt(document.getElementById('microprime-interval').value);

  if (isNaN(interval) || interval < 0 || interval > 168) {
    alert('Interval must be 0-168 hours (0 = disabled)');
    return;
  }

  try {
    const res = await fetch(`${API.cloudBase}/device/${selectedDeviceId}/command`, {
      method: 'POST',
      headers: { ...API.getAuthHeaders(), 'Content-Type': 'application/json' },
      body: JSON.stringify({
        command: 'set_sensor_config',
        params: { microprime_interval_hours: interval }
      })
    });

    if (res.ok) {
      if (interval === 0) {
        alert('‚úì Microprime disabled');
      } else {
        alert(`‚úì Microprime set to every ${interval} hours`);
      }
    } else {
      const err = await res.json().catch(() => ({}));
      alert('Failed: ' + (err.error || res.status));
    }
  } catch(e) {
    alert('Error: ' + e.message);
  }
}

// Reset device stats by group
async function resetStats(group) {
  if (!selectedDeviceId) {
    alert('Select a device first');
    return;
  }

  const labels = {
    'restarts': 'Restart counters (Clean + Unexpected)',
    'pump': 'Pump stats (Water + Runtime)'
  };

  if (!confirm(`Reset ${labels[group]}?\n\nDevice: ${selectedDeviceId}`)) {
    return;
  }

  try {
    const res = await fetch(`${API.cloudBase}/device/${selectedDeviceId}/command`, {
      method: 'POST',
      headers: { ...API.getAuthHeaders(), 'Content-Type': 'application/json' },
      body: JSON.stringify({
        command: 'reset_stats',
        params: { group: group }
      })
    });

    if (res.ok) {
      alert(`‚úì ${labels[group]} reset to 0`);
      // Update UI immediately
      if (group === 'restarts') {
        document.getElementById('stat-reboot-count').textContent = '0';
        document.getElementById('stat-clean-restarts').textContent = '0';
        document.getElementById('stat-unexpected-restarts').textContent = '0';
      } else if (group === 'pump') {
        document.getElementById('stat-total-water').textContent = '0 ml';
        document.getElementById('stat-pump-runtime').textContent = '0 sec';
      }
    } else {
      const err = await res.json().catch(() => ({}));
      alert('Failed: ' + (err.error || res.status));
    }
  } catch(e) {
    alert('Error: ' + e.message);
  }
}

// Cost estimate (using hardcoded firmware intervals)
function updateCostEstimate() {
  // Hardcoded in firmware: sensor=60min, battery=60min, system=30min
  const sensorMin = 60;
  const batteryMin = 60;
  const systemMin = 30;

  // Messages per month (30 days)
  const msgsPerDay = (1440/sensorMin) + (1440/batteryMin) + (1440/systemMin);
  const msgsPerMonth = Math.round(msgsPerDay * 30);

  // Free tier: 250,000 messages/month (first 12 months), then 0
  // Cost: $1 per million messages after free tier
  const freeTierLimit = 250000;
  const withinFreeTier = msgsPerMonth < freeTierLimit;
  const cost = withinFreeTier ? 0 : ((msgsPerMonth - freeTierLimit) / 1000000).toFixed(4);

  document.getElementById('est-messages').textContent = msgsPerMonth.toLocaleString();
  document.getElementById('est-free-tier').textContent = withinFreeTier ? '‚úì Yes' : '‚úó No';
  document.getElementById('est-free-tier').className = 'mono ' + (withinFreeTier ? 'ok' : 'danger');
  document.getElementById('est-cost').textContent = '$' + cost + '/month';
  document.getElementById('est-cost').className = 'mono ' + (cost == 0 ? 'ok' : 'danger');
}

// Admin email whitelist - uses ADMIN_EMAILS from common.js

// ============ User Management Functions ============

// All users data (from AWS)
let allUsersData = [];
// All devices data (from AWS)
let allDevicesData = [];

// Load users with whitelist status
async function loadUsers() {
  const container = document.getElementById('users-list');
  container.innerHTML = '<div class="muted">Loading...</div>';

  try {
    // Load whitelist from GitHub
    await loadWhitelist();

    // Load users from AWS
    const res = await fetch(`${API.cloudBase}/admin/users`, {
      headers: API.getAuthHeaders()
    });
    if (!res.ok) throw new Error('Failed to load users');
    allUsersData = await res.json();

    // Load devices from AWS
    const devRes = await fetch(`${API.cloudBase}/devices`, {
      headers: API.getAuthHeaders(),
      cache: 'no-store'
    });
    if (devRes.ok) {
      allDevicesData = await devRes.json();
    }

    if (allUsersData.length === 0) {
      container.innerHTML = '<div class="muted">No registered users</div>';
      return;
    }

    renderUsersList();
  } catch(e) {
    console.error('[Admin] Load users error:', e);
    container.innerHTML = '<div class="danger">Error loading users: ' + e.message + '</div>';
  }
}

// Render users list with current whitelist data
function renderUsersList() {
  const container = document.getElementById('users-list');
  const whitelistUsers = whitelistData?.users || {};

  // Sort: Admin first, then alphabetically
  const sortedUsers = [...allUsersData].sort((a, b) => {
    const aIsAdmin = ADMIN_EMAILS.includes(a.email.toLowerCase());
    const bIsAdmin = ADMIN_EMAILS.includes(b.email.toLowerCase());
    if (aIsAdmin && !bIsAdmin) return -1;
    if (!aIsAdmin && bIsAdmin) return 1;
    return a.email.localeCompare(b.email);
  });

  container.innerHTML = sortedUsers.map(u => {
    const email = u.email;
    const isWhitelisted = !!whitelistUsers[email];
    const isBanned = whitelistUsers[email]?.status === 'banned';
    const isSuspended = whitelistUsers[email]?.status === 'suspended';
    // Use ADMIN_EMAILS from common.js (not u.is_admin from DynamoDB which may not be set)
    const isAdmin = ADMIN_EMAILS.includes(email.toLowerCase());
    const verified = u.verified;

    // Get devices assigned to this user
    const userDevices = whitelistUsers[email]?.devices || [];

    // Status badge
    let statusBadge = '';
    if (isAdmin) {
      statusBadge = '<span style="color:#ffd700">üëë Admin</span>';
    } else if (isBanned) {
      statusBadge = '<span style="color:#f44">üö´ Banned</span>';
    } else if (isSuspended) {
      statusBadge = '<span style="color:#ff9800">‚è∏Ô∏è Suspended</span>';
    } else if (isWhitelisted) {
      statusBadge = '<span style="color:#4caf50">‚úÖ Whitelisted</span>';
    } else if (!verified) {
      statusBadge = '<span style="color:#999">‚ùå Not verified</span>';
    } else {
      statusBadge = '<span style="color:#999">‚è≥ Not whitelisted</span>';
    }

    // Action buttons based on status
    let actions = '';
    if (isAdmin) {
      // Admin sees ALL devices (total count), not whitelist-assigned
      const totalDevices = allDevicesData.length;
      actions = `<button onclick="toggleUserDevices('${email}')" style="font-size:11px;padding:4px 8px">üì± Devices (all ${totalDevices})</button>`;
    } else if (isBanned) {
      actions = `<button onclick="unbanUser('${email}')" style="font-size:11px;padding:4px 8px">Unban</button>`;
    } else if (isSuspended) {
      actions = `
        <button onclick="unsuspendUser('${email}')" style="font-size:11px;padding:4px 8px">Unsuspend</button>
        <button onclick="banUser('${email}')" style="font-size:11px;padding:4px 8px;background:#f44;color:#fff;border-color:#f44">Ban</button>
      `;
    } else if (isWhitelisted) {
      actions = `
        <button onclick="toggleUserDevices('${email}')" style="font-size:11px;padding:4px 8px">üì± Devices (${userDevices.length})</button>
        <button onclick="suspendUser('${email}')" style="font-size:11px;padding:4px 8px">Suspend</button>
        <button onclick="removeFromWhitelist('${email}')" style="font-size:11px;padding:4px 8px">Remove</button>
      `;
    } else if (verified) {
      actions = `
        <button onclick="addToWhitelist('${email}')" style="font-size:11px;padding:4px 8px;background:#4caf50;color:#fff;border-color:#4caf50">+ Whitelist</button>
        <button onclick="banUser('${email}')" style="font-size:11px;padding:4px 8px">Ban</button>
      `;
    } else {
      actions = `<button onclick="deleteUser('${email}')" style="font-size:11px;padding:4px 8px">Delete</button>`;
    }

    // Devices section (expandable) - show for Admin and Whitelisted users
    const canHaveDevices = isAdmin || isWhitelisted;

    // Admin sees ALL devices (read-only list), others see assigned devices
    let devicesSection = '';
    if (isAdmin) {
      // Admin: show all devices (no assign/unassign - Admin has access to all by default)
      devicesSection = `
        <div id="devices-${email.replace(/[@.]/g, '_')}" style="display:none;margin-top:8px;padding:8px;background:#1a1a2e;border-radius:8px">
          <div class="muted" style="margin-bottom:8px">Admin has full access to all devices</div>
          ${allDevicesData.map(d => {
            const shortId = d.device_id.replace('Polivalka-', '');
            const name = d.name && d.name !== d.device_id ? ` "${d.name}"` : '';
            const status = d.online ? 'üü¢' : '‚ö™';
            return `<div style="padding:4px 0"><span class="mono" style="color:#4caf50">${status} ${shortId}</span>${name}</div>`;
          }).join('')}
        </div>
      `;
    } else if (canHaveDevices && userDevices.length > 0) {
      devicesSection = `
        <div id="devices-${email.replace(/[@.]/g, '_')}" style="display:none;margin-top:8px;padding:8px;background:#1a1a2e;border-radius:8px">
          ${userDevices.map(devId => {
            const shortId = devId.replace('Polivalka-', '');
            return `
            <div style="display:flex;justify-content:space-between;align-items:center;padding:4px 0">
              <span class="mono" style="color:#4caf50">üì± ${shortId}</span>
              <button onclick="unassignDevice('${email}', '${devId}')" style="font-size:10px;padding:2px 6px">Unassign</button>
            </div>
          `}).join('')}
          <button onclick="showAssignDeviceDialog('${email}')" style="font-size:11px;padding:4px 8px;margin-top:8px">+ Assign device</button>
        </div>
      `;
    } else if (canHaveDevices) {
      devicesSection = `
        <div id="devices-${email.replace(/[@.]/g, '_')}" style="display:none;margin-top:8px;padding:8px;background:#1a1a2e;border-radius:8px">
          <div class="muted">No devices assigned</div>
          <button onclick="showAssignDeviceDialog('${email}')" style="font-size:11px;padding:4px 8px;margin-top:8px">+ Assign device</button>
        </div>
      `;
    }

    const lastLogin = u.last_login ? new Date(u.last_login).toLocaleDateString() : 'Never';

    return `
      <div style="padding:10px 0;border-bottom:1px solid #333">
        <div style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:8px">
          <div>
            <span style="color:#fff">${email}</span>
            <span style="margin-left:8px">${statusBadge}</span>
            <div class="muted" style="font-size:11px">Last login: ${lastLogin}</div>
          </div>
          <div style="display:flex;gap:4px;flex-wrap:wrap">
            ${actions}
          </div>
        </div>
        ${devicesSection}
      </div>
    `;
  }).join('');

  // Restore expanded sections
  restoreExpandedUsers();
}

// Track expanded user sections
const expandedUsers = new Set();

// Toggle devices visibility
function toggleUserDevices(email) {
  const id = 'devices-' + email.replace(/[@.]/g, '_');
  const el = document.getElementById(id);
  if (el) {
    const isHidden = el.style.display === 'none';
    el.style.display = isHidden ? 'block' : 'none';
    if (isHidden) {
      expandedUsers.add(email);
    } else {
      expandedUsers.delete(email);
    }
  }
}

// Restore expanded state after render
function restoreExpandedUsers() {
  expandedUsers.forEach(email => {
    const id = 'devices-' + email.replace(/[@.]/g, '_');
    const el = document.getElementById(id);
    if (el) el.style.display = 'block';
  });
}

// ============ Whitelist Actions ============

async function addToWhitelist(email) {
  if (!confirm(`Add ${email} to whitelist?`)) return;

  const success = await addUserToWhitelist(email, { status: 'active', devices: [] });
  if (success) {
    showToast(`${email} added to whitelist`, 'success');
    await loadWhitelist();
    renderUsersList();
  }
}

async function removeFromWhitelist(email) {
  const userData = whitelistData.users?.[email];
  const deviceCount = userData?.devices?.length || 0;

  let msg = `Remove ${email} from whitelist?`;
  if (deviceCount > 0) {
    msg += `\n\nThis will also unassign ${deviceCount} device(s).`;
  }

  if (!confirm(msg)) return;

  const success = await removeUserFromWhitelist(email);
  if (success) {
    showToast(`${email} removed from whitelist`, 'success');
    await loadWhitelist();
    renderUsersList();
  }
}

async function suspendUser(email) {
  if (!confirm(`Suspend ${email}? They will not be able to use their devices.`)) return;

  const success = await updateUserInWhitelist(email, { status: 'suspended' });
  if (success) {
    showToast(`${email} suspended`, 'warning');
    await loadWhitelist();
    renderUsersList();
  }
}

async function unsuspendUser(email) {
  const success = await updateUserInWhitelist(email, { status: 'active' });
  if (success) {
    showToast(`${email} unsuspended`, 'success');
    await loadWhitelist();
    renderUsersList();
  }
}

async function banUser(email) {
  if (!confirm(`BAN ${email}?\n\nThis will mark them as banned.`)) return;

  const success = await updateUserInWhitelist(email, { status: 'banned', devices: [] });
  if (success) {
    showToast(`${email} banned`, 'error');
    await loadWhitelist();
    renderUsersList();
  }
}

async function unbanUser(email) {
  if (!confirm(`Unban ${email}?`)) return;

  const success = await removeUserFromWhitelist(email);
  if (success) {
    showToast(`${email} unbanned`, 'success');
    await loadWhitelist();
    renderUsersList();
  }
}

async function deleteUser(email) {
  if (!confirm(`Delete unverified user ${email}?\n\nThis cannot be undone.`)) return;

  try {
    const res = await fetch(`${API.cloudBase}/admin/user/${encodeURIComponent(email)}/delete`, {
      method: 'POST',
      headers: API.getAuthHeaders()
    });

    if (res.ok) {
      showToast(`${email} deleted`, 'success');
      // Remove from local array and re-render
      allUsersData = allUsersData.filter(u => u.email !== email);
      renderUsersList();
    } else {
      const data = await res.json().catch(() => ({}));
      alert('Error: ' + (data.error || 'Failed to delete user'));
    }
  } catch(e) {
    alert('Error: ' + e.message);
  }
}

// ============ Device Assignment ============

let assignDialogEmail = null;

function showAssignDeviceDialog(email) {
  // Get available devices (not assigned to anyone)
  const assignedDevices = new Set();
  Object.values(whitelistData.users || {}).forEach(u => {
    (u.devices || []).forEach(d => assignedDevices.add(d));
  });

  const availableDevices = allDevicesData.filter(d => {
    // Compare using full device_id format (Polivalka-BC67E9)
    return !assignedDevices.has(d.device_id);
  });

  if (availableDevices.length === 0) {
    alert('No available devices to assign.\nAll devices are already assigned.');
    return;
  }

  assignDialogEmail = email;

  // Create modal dialog
  const modal = document.createElement('div');
  modal.id = 'assign-modal';
  modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.7);display:flex;align-items:center;justify-content:center;z-index:9999';

  const options = availableDevices.map(d => {
    const shortId = d.device_id.replace('Polivalka-', '');
    const name = d.device_name && d.device_name !== d.device_id ? ` (${d.device_name})` : '';
    // Value uses full format, display uses short
    return `<option value="${d.device_id}">${shortId}${name}</option>`;
  }).join('');

  modal.innerHTML = `
    <div style="background:#252540;padding:24px;border-radius:12px;min-width:300px;max-width:400px">
      <h3 style="color:#fff;margin:0 0 16px">Assign Device</h3>
      <p style="color:#ccc;margin:0 0 16px">Select device for <strong>${email}</strong></p>
      <select id="assign-device-select" style="width:100%;padding:12px;border-radius:8px;border:1px solid #555;background:#1a1a2e;color:#fff;font-size:16px;margin-bottom:16px">
        ${options}
      </select>
      <div style="display:flex;gap:12px;justify-content:flex-end">
        <button onclick="closeAssignDialog()" style="padding:10px 20px;border-radius:8px;border:1px solid #555;background:#333;color:#fff;cursor:pointer">Cancel</button>
        <button onclick="confirmAssignDevice()" style="padding:10px 20px;border-radius:8px;border:none;background:#4caf50;color:#fff;cursor:pointer;font-weight:600">Assign</button>
      </div>
    </div>
  `;

  document.body.appendChild(modal);
}

function closeAssignDialog() {
  const modal = document.getElementById('assign-modal');
  if (modal) modal.remove();
  assignDialogEmail = null;
}

async function confirmAssignDevice() {
  const select = document.getElementById('assign-device-select');
  if (select && assignDialogEmail) {
    const deviceId = select.value;
    const email = assignDialogEmail;
    closeAssignDialog();
    await assignDevice(email, deviceId);
  }
}

async function assignDevice(email, deviceId) {
  // Use full device_id format: Polivalka-BC67E9 (standardized everywhere)
  const fullId = deviceId.startsWith('Polivalka-') ? deviceId : `Polivalka-${deviceId}`;
  const shortId = fullId.replace('Polivalka-', ''); // For display only

  // Ensure whitelist is loaded
  if (!whitelistData || !whitelistData.users) {
    await loadWhitelist();
  }

  const existingUser = whitelistData.users?.[email];
  const devices = existingUser?.devices || [];

  if (devices.includes(fullId)) {
    alert('Device already assigned to this user');
    return;
  }

  // Add device to user's list (full format)
  devices.push(fullId);

  let success;
  if (existingUser) {
    // Update existing user
    success = await updateUserInWhitelist(email, { devices });
  } else {
    // Auto-add admin to whitelist if not there
    const isAdminEmail = ADMIN_EMAILS.includes(email.toLowerCase());
    if (isAdminEmail) {
      success = await addUserToWhitelist(email, { status: 'active', devices });
      console.log('[Admin] Auto-added admin to whitelist:', email);
    } else {
      console.error('[Admin] User not in whitelist:', email);
      alert('User not in whitelist');
      return;
    }
  }

  if (success) {
    // Add to device history (full format)
    await addDeviceHistoryEntry(fullId, {
      event: 'assigned',
      to: email
    });

    showToast(`${shortId} assigned to ${email}`, 'success');
    await loadWhitelist();
    renderUsersList();
  }
}

async function unassignDevice(email, deviceId) {
  if (!confirm(`Unassign ${deviceId} from ${email}?`)) return;

  const devices = whitelistData.users?.[email]?.devices || [];
  const newDevices = devices.filter(d => d !== deviceId);

  const success = await updateUserInWhitelist(email, { devices: newDevices });
  if (success) {
    // Add to device history
    await addDeviceHistoryEntry(deviceId, {
      event: 'unassigned',
      from: email
    });

    showToast(`${deviceId} unassigned`, 'success');
    await loadWhitelist();
    renderUsersList();
  }
}

// ============ Device Management Functions ============

async function loadArchivedDevices() {
  const container = document.getElementById('archived-list');
  try {
    const res = await fetch(`${API.cloudBase}/admin/devices/archived`, {
      headers: API.getAuthHeaders()
    });
    if (!res.ok) throw new Error('Failed to load');
    const devices = await res.json();

    if (devices.length === 0) {
      container.innerHTML = '<div class="muted">No archived devices</div>';
      return;
    }

    container.innerHTML = devices.map(d => {
      const shortId = d.device_id.replace('Polivalka-', '');
      const date = d.archived_at ? new Date(d.archived_at * 1000).toLocaleDateString() : '‚Äî';
      return `
        <div style="display:flex;justify-content:space-between;align-items:center;padding:8px 0;border-bottom:1px solid #333">
          <div>
            <span class="mono" style="color:#ff9800">${shortId}</span>
            <span class="muted" style="margin-left:8px">${d.name !== d.device_id ? d.name : ''}</span>
            <div class="muted" style="font-size:11px">Archived: ${date}</div>
          </div>
          <button onclick="restoreArchived('${d.device_id}')" style="font-size:12px;padding:4px 8px">Restore</button>
        </div>
      `;
    }).join('');
  } catch(e) {
    container.innerHTML = '<div class="danger">Error loading archived devices</div>';
  }
}

// Load deleted devices list
async function loadDeletedDevices() {
  const container = document.getElementById('deleted-list');
  try {
    const res = await fetch(`${API.cloudBase}/admin/devices/deleted`, {
      headers: API.getAuthHeaders()
    });
    if (!res.ok) throw new Error('Failed to load');
    const devices = await res.json();

    if (devices.length === 0) {
      container.innerHTML = '<div class="muted">No deleted devices</div>';
      return;
    }

    container.innerHTML = devices.map(d => {
      const shortId = d.device_id.replace('Polivalka-', '');
      const date = d.deleted_at ? new Date(d.deleted_at * 1000).toLocaleDateString() : '‚Äî';
      return `
        <div style="display:flex;justify-content:space-between;align-items:center;padding:8px 0;border-bottom:1px solid #333">
          <div>
            <span class="mono" style="color:#f44">${shortId}</span>
            <span class="muted" style="margin-left:8px">${d.name !== d.device_id ? d.name : ''}</span>
            <div class="muted" style="font-size:11px">Deleted: ${date}</div>
          </div>
          <button onclick="restoreDeleted('${d.device_id}')" style="font-size:12px;padding:4px 8px">Restore</button>
        </div>
      `;
    }).join('');
  } catch(e) {
    container.innerHTML = '<div class="danger">Error loading deleted devices</div>';
  }
}

// Archive selected device
async function archiveDevice() {
  if (!selectedDeviceId) {
    alert('Select a device first');
    return;
  }

  const shortId = selectedDeviceId.replace('Polivalka-', '');
  if (!confirm(`Archive device ${shortId}?\n\nIt will be hidden from Fleet but continue to work and send data.`)) {
    return;
  }

  try {
    const res = await fetch(`${API.cloudBase}/admin/device/${selectedDeviceId}/archive`, {
      method: 'POST',
      headers: API.getAuthHeaders()
    });
    const data = await res.json();

    if (res.ok) {
      alert(`‚úì Device ${shortId} archived`);
      loadDevices();  // Refresh device list
      loadArchivedDevices();  // Refresh archived list
      document.getElementById('device-select').value = '';
      document.getElementById('device-info').style.display = 'none';
      updateDangerButtons(false);
    } else {
      alert('Error: ' + (data.error || 'Unknown error'));
    }
  } catch(e) {
    alert('Error: ' + e.message);
  }
}

// Hard delete selected device
async function deleteDevice() {
  if (!selectedDeviceId) {
    alert('Select a device first');
    return;
  }

  const shortId = selectedDeviceId.replace('Polivalka-', '');

  // Double confirmation with ID input
  const confirmId = prompt(`‚ö†Ô∏è DELETE DEVICE\n\nThis will deactivate the certificate and the device will no longer be able to connect to the cloud.\n\nTo confirm, type the device ID: ${shortId}`);

  if (confirmId !== shortId) {
    if (confirmId !== null) alert('Device ID does not match. Deletion cancelled.');
    return;
  }

  try {
    const res = await fetch(`${API.cloudBase}/admin/device/${selectedDeviceId}/delete`, {
      method: 'POST',
      headers: API.getAuthHeaders()
    });
    const data = await res.json();

    if (res.ok) {
      alert(`‚úì Device ${shortId} deleted\n\nCertificate deactivated.`);
      loadDevices();
      loadDeletedDevices();
      document.getElementById('device-select').value = '';
      document.getElementById('device-info').style.display = 'none';
      updateDangerButtons(false);
    } else {
      alert('Error: ' + (data.error || 'Unknown error'));
    }
  } catch(e) {
    alert('Error: ' + e.message);
  }
}

// Restore device from archive
async function restoreArchived(deviceId) {
  const shortId = deviceId.replace('Polivalka-', '');
  if (!confirm(`Restore ${shortId} from archive?`)) return;

  try {
    const res = await fetch(`${API.cloudBase}/admin/device/${deviceId}/restore-archive`, {
      method: 'POST',
      headers: API.getAuthHeaders()
    });
    const data = await res.json();

    if (res.ok) {
      alert(`‚úì Device ${shortId} restored`);
      loadDevices();
      loadArchivedDevices();
    } else {
      alert('Error: ' + (data.error || 'Unknown error'));
    }
  } catch(e) {
    alert('Error: ' + e.message);
  }
}

// Restore deleted device (reactivate certificate)
async function restoreDeleted(deviceId) {
  const shortId = deviceId.replace('Polivalka-', '');
  if (!confirm(`Restore ${shortId}?\n\nThis will reactivate the certificate and the device will be able to connect again.`)) return;

  try {
    const res = await fetch(`${API.cloudBase}/admin/device/${deviceId}/restore`, {
      method: 'POST',
      headers: API.getAuthHeaders()
    });
    const data = await res.json();

    if (res.ok) {
      alert(`‚úì Device ${shortId} restored\n\nCertificate reactivated.`);
      loadDevices();
      loadDeletedDevices();
    } else {
      alert('Error: ' + (data.error || 'Unknown error'));
    }
  } catch(e) {
    alert('Error: ' + e.message);
  }
}

// Enable/disable danger zone buttons
function updateDangerButtons(enabled) {
  const archiveBtn = document.getElementById('btn-archive');
  const deleteBtn = document.getElementById('btn-delete');
  archiveBtn.disabled = !enabled;
  deleteBtn.disabled = !enabled;
  archiveBtn.style.opacity = enabled ? '1' : '0.5';
  deleteBtn.style.opacity = enabled ? '1' : '0.5';
}

// Check admin access
function checkAdminAccess() {
  const userEmail = localStorage.getItem('user_email');
  if (!userEmail) {
    // Not logged in
    window.location.href = 'login.html';
    return false;
  }
  if (!isAdmin()) {
    // Not admin - show access denied
    document.body.innerHTML = `
      <div style="display:flex;align-items:center;justify-content:center;height:100vh;background:#1a1a2e">
        <div style="text-align:center;color:#fff">
          <h1 style="color:#f44">‚õî Access Denied</h1>
          <p>This page is for administrators only.</p>
          <a href="/" style="color:#4caf50">‚Üê Back to Fleet</a>
        </div>
      </div>
    `;
    return false;
  }
  return true;
}

// Get device from URL if present
const urlDeviceId = new URLSearchParams(window.location.search).get('device');

// Update back link - if came from device page, go back there
if (urlDeviceId) {
  const backLink = document.getElementById('back-link');
  backLink.href = `home.html?device=${urlDeviceId}`;
  backLink.textContent = '‚Üê Device';
}

// Init
if (checkAdminAccess()) {
  // If came from device page, show cards immediately with "Loading..."
  if (urlDeviceId) {
    document.getElementById('selected-device-id').textContent = urlDeviceId;
    document.getElementById('device-info').style.display = 'block';
    document.getElementById('device-stats-card').style.display = 'block';
    document.getElementById('selected-device-lastseen').textContent = 'Loading...';
    document.getElementById('stat-firmware').textContent = 'Loading...';
  }

  loadDevices().then(() => {
    // Auto-select device if came from device page
    if (urlDeviceId) {
      const select = document.getElementById('device-select');
      select.value = urlDeviceId;
      if (select.value === urlDeviceId) {
        loadDeviceConfig();  // Load config for pre-selected device
      }
    }
  });
  loadUsers();           // Restored - endpoint fixed
  loadPendingClaimsUI(); // Load pending claims
  loadArchivedDevices();
  loadDeletedDevices();
  updateCostEstimate();
}
</script>
</body></html>
